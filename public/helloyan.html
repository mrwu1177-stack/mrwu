<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŠ å¯†è´§å¸å¼‚åŠ¨ç›‘æ§ä¸­å¿ƒ - Mrwu1177</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
      color: #e2e8f0;
      min-height: 100vh;
      margin: 0;
      padding: 0;
    }
    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: .5; }
    }
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
    .overflow-x-auto::-webkit-scrollbar {
      height: 6px;
    }
    .overflow-x-auto::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
      border-radius: 3px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb {
      background: rgba(100, 116, 139, 0.5);
      border-radius: 3px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb:hover {
      background: rgba(100, 116, 139, 0.8);
    }
    /* å¡ç‰‡æ‚¬åœæ•ˆæœ */
    .card-hover {
      transition: all 0.3s ease;
    }
    .card-hover:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border-color: rgba(16, 185, 129, 0.5);
    }
    /* æ¸å˜è¾¹æ¡†åŠ¨ç”» */
    @keyframes border-glow {
      0%, 100% { border-color: rgba(16, 185, 129, 0.3); }
      50% { border-color: rgba(16, 185, 129, 0.6); }
    }
    .border-glow {
      animation: border-glow 3s ease-in-out infinite;
    }

    /* å“åº”å¼å¸ƒå±€ */
    @media (min-width: 768px) {
      .main-layout {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 12px;
        align-items: start;
      }
      .signal-section {
        position: sticky;
        top: 16px;
      }
    }

    @media (max-width: 767px) {
      .main-layout {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .container {
        padding: 8px;
      }
      .signal-section {
        min-height: 50vh;
      }
      .secondary-section {
        max-height: none;
      }
      .news-section {
        max-height: 300px;
      }
      .market-section {
        max-height: auto;
      }
      .log-section {
        max-height: 150px;
      }
      /* ç§»åŠ¨ç«¯æ ‡é¢˜ä¼˜åŒ– */
      .signal-section h2 {
        font-size: 1rem;
      }
      .signal-section .text-lg {
        font-size: 1.25rem;
      }
    }

    /* ä¿¡å·ç›‘æ§çªå‡ºæ ·å¼ */
    .signal-highlight {
      border: 2px solid rgba(16, 185, 129, 0.4);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.15);
    }

    /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .mobile-compact {
      padding: 8px;
    }
    .mobile-compact .text-xs {
      font-size: 10px;
    }
    .mobile-compact .text-sm {
      font-size: 12px;
    }
    .mobile-compact .p-2 {
      padding: 6px;
    }
    .mobile-compact .p-3 {
      padding: 8px;
    }
    .mobile-compact .gap-2 {
      gap: 6px;
    }
    .mobile-compact .gap-3 {
      gap: 8px;
    }

    /* è¡¨æ ¼å“åº”å¼ */
    @media (max-width: 767px) {
      .anomaly-table {
        font-size: 10px;
      }
      .anomaly-table th,
      .anomaly-table td {
        padding: 4px 6px;
      }
      .anomaly-table th:nth-child(4),
      .anomaly-table th:nth-child(7),
      .anomaly-table td:nth-child(4),
      .anomaly-table td:nth-child(7) {
        display: none;
      }
    }

    /* è¶…å°å±å¹•ä¼˜åŒ–ï¼ˆ< 375pxï¼‰ */
    @media (max-width: 374px) {
      .signal-section h2 {
        font-size: 0.875rem;
      }
      .signal-section .text-lg {
        font-size: 1.125rem;
      }
      .anomaly-table {
        font-size: 9px;
      }
      .anomaly-table th,
      .anomaly-table td {
        padding: 3px 4px;
      }
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="container mx-auto px-3 py-4 max-w-7xl flex flex-col min-h-screen">
    <!-- Header -->
    <header class="bg-gradient-to-r from-emerald-600 to-teal-600 rounded-2xl p-3 mb-3 text-white shadow-lg shrink-0">
      <div class="flex items-center gap-3">
        <h1 class="text-xl font-bold">HelloYan</h1>
        <div id="apiStatus" class="flex items-center gap-1.5 px-2 py-0.5 bg-white/20 rounded-lg text-xs">
          <div id="apiStatusIndicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse"></div>
          <span id="apiStatusText">APIè¿æ¥ä¸­</span>
        </div>
        <p id="lastUpdate" class="text-white/70 text-xs ml-auto">æœ€åæ›´æ–°: --</p>
      </div>
      <div id="progressBar" class="mt-2 h-1 bg-white/20 rounded-full overflow-hidden hidden">
        <div id="progressFill" class="h-full bg-white/80 transition-all duration-300" style="width: 0%"></div>
      </div>
    </header>

        <!-- Main Grid - å“åº”å¼å¸ƒå±€ -->
    <div class="main-layout flex-1 overflow-hidden">
      <!-- å·¦ä¾§/é¡¶éƒ¨ï¼šä¿¡å·ç›‘æ§æ¿å—ï¼ˆä¸»è¦åŒºåŸŸï¼‰ -->
      <div class="signal-section bg-slate-800/50 rounded-xl shadow-lg border border-emerald-500/30 overflow-hidden flex flex-col signal-highlight">
        <div class="p-3 bg-gradient-to-r from-emerald-600/30 to-teal-600/30 border-b border-emerald-500/30 shrink-0">
          <div class="flex items-center justify-between flex-wrap gap-2">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-lg flex items-center justify-center text-white text-lg shadow-lg">
                ğŸ¯
              </div>
              <div>
                <h2 class="text-base font-bold text-white">ä¿¡å·ç›‘æ§</h2>
                <p class="text-xs text-emerald-200">å®æ—¶å¼‚åŠ¨æ£€æµ‹</p>
              </div>
            </div>
            <div class="flex items-center gap-2 flex-wrap">
              <!-- æ ‡ç­¾é¡µåˆ‡æ¢ -->
              <div class="flex gap-1 bg-slate-700/50 rounded-lg p-0.5">
                <button id="tabAnomaly" onclick="switchSignalTab('anomaly')" class="px-3 py-1.5 text-xs rounded transition-all bg-emerald-600 text-white font-semibold">
                  å¼‚åŠ¨ç›‘æ§
                </button>
                <button id="tabTrade" onclick="switchSignalTab('trade')" class="px-3 py-1.5 text-xs rounded transition-all text-slate-400 hover:text-white">
                  ä¹°å–ç‚¹å‚è€ƒ
                </button>
              </div>
              <!-- APIé€‰æ‹©å™¨ -->
              <select id="apiSelector" onchange="switchApiProvider()" class="px-2 py-1.5 bg-slate-700 border border-slate-600 rounded-lg text-xs text-white focus:outline-none focus:ring-2 focus:ring-emerald-500">
                <option value="bybit">Bybit</option>
                <option value="okx">OKX</option>
                <option value="binance">Binance</option>
              </select>
              <div id="anomalyStatusIndicator" class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse"></div>
              <span id="anomalyStatus" class="text-xs text-slate-400">åˆ†æä¸­</span>
            </div>
          </div>
        </div>

        <!-- æ‰«æç»Ÿè®¡ä¿¡æ¯ -->
        <div id="analysisStats" class="hidden px-3 py-2 bg-slate-700/30 border-b border-slate-700 shrink-0">
          <div class="flex items-center gap-4 text-xs flex-wrap">
            <div class="flex items-center gap-1 bg-slate-800/50 px-2 py-1 rounded">
              <span class="text-slate-400">æ‰«æ:</span>
              <span id="scannedCount" class="text-white font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1 bg-slate-800/50 px-2 py-1 rounded">
              <span class="text-slate-400">ä¿¡å·:</span>
              <span id="totalSignals" class="text-green-400 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1 bg-slate-800/50 px-2 py-1 rounded">
              <span class="text-slate-400">ä¸»æ‹‰:</span>
              <span id="mainUpCount" class="text-green-300 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1 bg-slate-800/50 px-2 py-1 rounded">
              <span class="text-slate-400">ä¸»ç ¸:</span>
              <span id="mainDownCount" class="text-orange-300 font-semibold">0</span>
            </div>
          </div>
        </div>

        <div class="p-3 flex-1 overflow-hidden flex flex-col">
          <!-- å¼‚åŠ¨ç›‘æ§æ ‡ç­¾é¡µå†…å®¹ -->
          <div id="anomalyTabContent" class="flex-1 flex flex-col">
            <div id="anomalyLoading" class="text-center py-8 text-slate-500 shrink-0">
              <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-400 mx-auto mb-2"></div>
              <p class="text-sm">æ­£åœ¨åˆ†æå¸‚åœºå¼‚åŠ¨...</p>
            </div>
            <div id="anomalyEmpty" class="hidden text-center py-8 text-slate-500 shrink-0">
              <div class="text-4xl mb-2">ğŸ¯</div>
              <p class="text-sm">æš‚æ— å¼‚åŠ¨ä¿¡å·ï¼Œç­‰å¾…æ£€æµ‹...</p>
            </div>
            <div id="anomalyContent" class="hidden flex-1 overflow-x-auto overflow-y-auto">
              <table class="w-full text-xs anomaly-table">
                <thead class="sticky top-0 bg-slate-700/90 backdrop-blur">
                  <tr>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300 cursor-pointer hover:bg-slate-600 rounded" onclick="sortAnomalySignals('symbol')">
                      åç§° <span id="sortSymbol"></span>
                    </th>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300">ä¿¡å·ç±»å‹</th>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300 cursor-pointer hover:bg-slate-600 rounded" onclick="sortAnomalySignals('price')">
                      ä»·æ ¼ <span id="sortPrice"></span>
                    </th>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300">æ”¾é‡æ•°æ®</th>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300 cursor-pointer hover:bg-slate-600 rounded" onclick="sortAnomalySignals('change')">
                      24hæ¶¨è·Œ <span id="sortChange"></span>
                    </th>
                    <th class="px-3 py-2 text-left font-semibold text-slate-300 cursor-pointer hover:bg-slate-600 rounded" onclick="sortAnomalySignals('time')">
                      æ—¶é—´ <span id="sortTime"></span>
                    </th>
                  </tr>
                </thead>
                <tbody id="anomalySignalsTable">
                </tbody>
              </table>
            </div>
          </div>

          <!-- ä¹°å–ç‚¹å‚è€ƒæ ‡ç­¾é¡µå†…å®¹ -->
          <div id="tradeTabContent" class="hidden flex-1 flex flex-col">
            <div id="tradeLoading" class="text-center py-8 text-slate-500 shrink-0">
              <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-400 mx-auto mb-2"></div>
              <p class="text-sm">æ­£åœ¨è®¡ç®—ä¹°å–ç‚¹...</p>
            </div>
            <div id="tradeEmpty" class="hidden text-center py-8 text-slate-500 shrink-0">
              <p class="text-sm">è¾“å…¥äº¤æ˜“å¯¹ç¬¦å·ï¼Œä¾‹å¦‚: BTCUSDT</p>
            </div>
            <div id="tradeContent" class="hidden flex-1 flex flex-col gap-3 overflow-y-auto">
              <!-- æœç´¢æ¡† -->
              <div class="flex gap-2 shrink-0">
                <input type="text" id="tradeSymbolInput" placeholder="è¾“å…¥äº¤æ˜“å¯¹ç¬¦å· (å¦‚: BTCUSDT)"
                  class="flex-1 px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm text-white focus:outline-none focus:ring-2 focus:ring-emerald-500">
                <button onclick="analyzeTradePoints()" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-sm rounded-lg transition-all font-semibold">
                  åˆ†æ
                </button>
              </div>

              <!-- å¸ƒæ—å¸¦æŒ‡æ ‡ -->
              <div id="bollingerBandsSection" class="p-4 bg-slate-700/50 rounded-lg border border-slate-600 shrink-0">
                <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ“ˆ å¸ƒæ—å¸¦æŒ‡æ ‡ (Bollinger Bands)</h3>
                <div class="grid grid-cols-3 gap-3 text-xs">
                  <div class="p-3 bg-slate-800/50 rounded-lg text-center">
                    <div class="text-slate-400 mb-1">ä¸Šè½¨ (UB)</div>
                    <div id="upperBand" class="text-orange-400 font-bold text-lg">--</div>
                  </div>
                  <div class="p-3 bg-slate-800/50 rounded-lg text-center">
                    <div class="text-slate-400 mb-1">ä¸­è½¨ (MB)</div>
                    <div id="middleBand" class="text-emerald-400 font-bold text-lg">--</div>
                  </div>
                  <div class="p-3 bg-slate-800/50 rounded-lg text-center">
                    <div class="text-slate-400 mb-1">ä¸‹è½¨ (LB)</div>
                    <div id="lowerBand" class="text-green-400 font-bold text-lg">--</div>
                  </div>
                </div>
              </div>

              <!-- ä¹°å–ç‚¹æç¤º -->
              <div id="tradeSignalsSection" class="p-4 bg-slate-700/50 rounded-lg border border-slate-600 shrink-0">
                <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ¯ ä¹°å–ç‚¹æç¤º</h3>
                <div id="tradeSignals" class="space-y-2">
                  <div class="text-slate-400 text-xs">ç­‰å¾…åˆ†æ...</div>
                </div>
              </div>

              <!-- å½“å‰ä»·æ ¼ -->
              <div id="currentPriceSection" class="p-4 bg-slate-700/50 rounded-lg border border-slate-600 shrink-0">
                <h3 class="font-bold text-sm mb-2 text-slate-300">ğŸ’° å½“å‰ä»·æ ¼</h3>
                <div class="text-3xl font-bold text-white" id="currentPrice">--</div>
                <div class="text-xs text-slate-400 mt-1">1å°æ—¶å‘¨æœŸ</div>
              </div>

              <!-- ä»·æ ¼ä½ç½® -->
              <div id="pricePositionSection" class="p-4 bg-slate-700/50 rounded-lg border border-slate-600 shrink-0">
                <h3 class="font-bold text-sm mb-2 text-slate-300">ğŸ“ ä»·æ ¼ä½ç½®</h3>
                <div class="w-full bg-slate-800 rounded-full h-6 relative">
                  <div id="pricePositionBar" class="absolute bg-emerald-500 h-full rounded-full transition-all" style="left: 0; width: 0;"></div>
                  <div id="pricePositionIndicator" class="absolute w-4 h-4 bg-white rounded-full transition-all shadow-lg" style="left: 0; top: 0.25rem;"></div>
                </div>
                <div class="flex justify-between mt-2 text-xs text-slate-400">
                  <span>ä¸‹è½¨</span>
                  <span>ä¸­è½¨</span>
                  <span>ä¸Šè½¨</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§/åº•éƒ¨ï¼šæ¬¡è¦ä¿¡æ¯ï¼ˆæ–°é—»+ç»¼åˆæ•°æ®ï¼‰ -->
      <div class="secondary-section flex flex-col gap-3">
        <!-- å¸‚åœºå¿«é€Ÿæ¦‚è§ˆ -->
        <div class="market-section bg-slate-800/50 rounded-xl shadow-sm border border-slate-700 overflow-hidden shrink-0">
          <div class="p-2 bg-gradient-to-r from-slate-700/40 to-slate-800/40 border-b border-slate-700">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span class="text-lg">ğŸ“Š</span>
                <h2 class="text-sm font-semibold text-white">å¸‚åœºæ¦‚è§ˆ</h2>
              </div>
              <span id="marketDataLastUpdate" class="text-xs text-slate-500">æ›´æ–°: --</span>
            </div>
          </div>
          <div class="p-3 grid grid-cols-2 gap-2">
            <div class="bg-slate-900/50 rounded-lg p-2 border border-slate-700">
              <div class="text-xs text-slate-400 mb-1">BTC</div>
              <div id="btcPrice" class="text-sm font-semibold text-white">--</div>
              <div id="btcChange" class="text-xs text-slate-400 mt-0.5">--</div>
            </div>
            <div class="bg-slate-900/50 rounded-lg p-2 border border-slate-700">
              <div class="text-xs text-slate-400 mb-1">ETH</div>
              <div id="ethPrice" class="text-sm font-semibold text-white">--</div>
              <div id="ethChange" class="text-xs text-slate-400 mt-0.5">--</div>
            </div>
            <div class="bg-slate-900/50 rounded-lg p-2 border border-slate-700">
              <div class="text-xs text-slate-400 mb-1">æ€»å¸‚å€¼</div>
              <div id="totalMarketCap" class="text-sm font-semibold text-white">--</div>
            </div>
            <div class="bg-slate-900/50 rounded-lg p-2 border border-slate-700">
              <div class="text-xs text-slate-400 mb-1">24häº¤æ˜“é‡</div>
              <div id="totalVolume" class="text-sm font-semibold text-white">--</div>
            </div>
          </div>
          <!-- æè´ªæŒ‡æ•° -->
          <div class="px-3 pb-3">
            <div class="bg-gradient-to-r from-slate-700/50 via-slate-600/50 to-emerald-700/50 rounded-lg p-3 border border-slate-700">
              <div class="flex items-center justify-between">
                <div>
                  <div class="text-xs text-slate-400 mb-1">ğŸ˜± æè´ªæŒ‡æ•°</div>
                  <div class="flex items-baseline gap-2">
                    <span id="fearGreed" class="text-xl font-bold text-white">--</span>
                    <span id="fearGreedLabel" class="text-sm text-slate-300">--</span>
                  </div>
                </div>
                <div class="text-right">
                  <div class="text-xs text-slate-500">å¸‚åœºæƒ…ç»ª</div>
                  <div class="text-xs text-slate-500">æ›´æ–°: <span id="fearGreedUpdate">--</span></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- æ–°é—»ç»¼åˆ -->
        <div class="news-section bg-slate-800/50 rounded-xl shadow-sm border border-slate-700 overflow-hidden flex-1 flex flex-col">
          <div class="p-2 bg-gradient-to-r from-slate-700/40 to-slate-800/40 border-b border-slate-700 shrink-0">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-1">
                <span class="text-lg">ğŸ“°</span>
                <h2 class="text-sm font-semibold text-white">æ–°é—»ç»¼åˆ</h2>
              </div>
              <div class="flex gap-1">
                <button id="tabLatest" onclick="switchTab('latest')" class="px-2 py-1 rounded-lg text-xs font-medium transition-all bg-orange-500 text-white">æœ€æ–°</button>
                <button id="tabHot" onclick="switchTab('hot')" class="px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-700 text-slate-300 hover:bg-slate-600">çƒ­é—¨</button>
              </div>
            </div>
          </div>
          <div class="p-2 flex-1 overflow-hidden flex flex-col">
            <div id="newsLoading" class="text-center py-3 text-slate-500 shrink-0">åŠ è½½ä¸­...</div>
            <div id="newsEmpty" class="hidden text-center py-3 text-slate-500 shrink-0">æš‚æ— æ•°æ®</div>
            <div id="newsContent" class="hidden flex-1 overflow-x-auto overflow-y-auto">
              <div id="contentHot" class="hidden grid grid-cols-1 gap-2"></div>
              <div id="contentLatest" class="grid grid-cols-1 gap-2"></div>
              <div id="contentKol" class="hidden grid grid-cols-1 gap-2"></div>
            </div>
          </div>
        </div>

        <!-- ç›‘æ§æ—¥å¿—ï¼ˆç´§å‡‘ç‰ˆï¼‰ -->
        <div class="log-section bg-slate-800/50 rounded-xl shadow-sm border border-slate-700 overflow-hidden shrink-0">
          <div class="p-2 bg-gradient-to-r from-slate-700/40 to-slate-800/40 border-b border-slate-700">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span class="text-sm">ğŸ“‹</span>
                <h2 class="text-sm font-semibold text-white">ç›‘æ§æ—¥å¿—</h2>
              </div>
              <div class="flex gap-1">
                <button onclick="toggleLogs()" id="logToggleBtn" class="px-2 py-1 rounded-lg text-xs bg-slate-700 text-slate-300 hover:bg-slate-600 transition-all">å±•å¼€</button>
              </div>
            </div>
          </div>
          <div id="logContainer" class="p-2 h-24 overflow-y-auto font-mono text-xs hidden" style="background: rgba(15, 23, 42, 0.5);"></div>
        </div>
      </div>
    </div>


    <!-- ç›‘æ§æ—¥å¿—é¢æ¿ -->
    <div class="bg-slate-800/50 rounded-xl shadow-sm border border-slate-700 overflow-hidden flex flex-col shrink-0 mt-3" style="max-height: 225px; min-height: 150px;">
      <div class="p-2 bg-gradient-to-r from-slate-700/40 to-slate-800/40 border-b border-slate-700 shrink-0">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <div class="w-7 h-7 bg-gradient-to-br from-slate-500 to-gray-600 rounded-lg flex items-center justify-center text-white text-sm">
              ğŸ“‹
            </div>
            <div>
              <h2 class="text-sm font-semibold text-white">ç›‘æ§æ—¥å¿—</h2>
              <p class="text-xs text-slate-400">å®æ—¶æ˜¾ç¤ºAPIè°ƒç”¨çŠ¶æ€å’Œç³»ç»Ÿä¿¡æ¯</p>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <!-- æ—¥å¿—ç­›é€‰æŒ‰é’® -->
            <div class="flex bg-slate-700/50 rounded-lg p-0.5">
              <button onclick="filterLogs('all')" id="filterAll" class="px-2 py-1 text-xs bg-emerald-600 text-white rounded transition-all">å…¨éƒ¨</button>
              <button onclick="filterLogs('normal')" id="filterNormal" class="px-2 py-1 text-xs text-slate-300 hover:bg-slate-600 rounded transition-all">æ­£å¸¸</button>
              <button onclick="filterLogs('error')" id="filterError" class="px-2 py-1 text-xs text-orange-300 hover:bg-orange-900/50 rounded transition-all">æŠ¥é”™</button>
              <button onclick="filterLogs('warning')" id="filterWarning" class="px-2 py-1 text-xs text-yellow-300 hover:bg-yellow-900/50 rounded transition-all">é”™è¯¯æç¤º</button>
            </div>
            <div class="w-px h-4 bg-slate-600"></div>
            <button onclick="clearLogs()" class="px-2 py-1 rounded-lg text-xs bg-slate-700 text-slate-300 hover:bg-slate-600 transition-all">
              æ¸…ç©ºæ—¥å¿—
            </button>
            <button onclick="clearAllHistory()" class="px-2 py-1 rounded-lg text-xs bg-orange-700/50 text-orange-300 hover:bg-orange-700 transition-all" title="æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®ï¼ˆä¿¡å·ã€æ–°é—»ã€æ—¥å¿—ï¼‰">
              æ¸…é™¤å†å²
            </button>
            <button onclick="toggleLogs()" id="logToggleBtn" class="px-2 py-1 rounded-lg text-xs bg-slate-700 text-slate-300 hover:bg-slate-600 transition-all">
              å±•å¼€
            </button>
          </div>
        </div>
      </div>
      <div id="logContainer" class="p-2 flex-1 overflow-y-auto font-mono text-xs hidden" style="background: rgba(15, 23, 42, 0.5);">
        <!-- æ—¥å¿—å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
      </div>
    </div>

    <!-- Footer -->
    <div class="mt-3 text-center text-xs text-slate-500 shrink-0 pb-2">
      <p>Â© 2025 åŠ å¯†è´§å¸å¼‚åŠ¨ç›‘æ§ä¸­å¿ƒ | æ•°æ®æ¥æº: Binance API Â· Followin API</p>
    </div>

    <!-- API Key é…ç½®æ¨¡æ€æ¡† -->
    <div id="apiKeyModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.8);">
      <div class="bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 border border-slate-700 shadow-2xl">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-white">Followin API é…ç½®</h3>
          <button onclick="hideApiKeyConfig()" class="text-slate-400 hover:text-white text-2xl">&times;</button>
        </div>
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-slate-300 mb-2">API Key</label>
            <input
              type="text"
              id="apiKeyInput"
              placeholder="è¯·è¾“å…¥æ‚¨çš„Followin API Key"
              class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500"
            />
            <button
              onclick="useDefaultApiKey()"
              class="mt-2 text-xs text-emerald-400 hover:text-emerald-300 underline"
            >
              ä½¿ç”¨é»˜è®¤API Key
            </button>
          </div>
          <div class="text-xs text-slate-400 space-y-1">
            <p>ğŸ’¡ è·å–API Keyï¼š</p>
            <p>1. è®¿é—® <a href="https://followin.io" target="_blank" class="text-emerald-400 hover:underline">followin.io</a> å®˜ç½‘</p>
            <p>2. æ³¨å†Œ/ç™»å½•è´¦å·</p>
            <p>3. åœ¨ä¸ªäººä¸­å¿ƒ/å¼€å‘è€…ä¸­å¿ƒè·å–API Key</p>
            <p class="text-green-400 mt-2">âœ… å½“å‰å·²é¢„ç½®é»˜è®¤API Keyï¼Œå¯æ­£å¸¸ä½¿ç”¨</p>
            <p class="text-yellow-400 mt-1">âš ï¸ API Keyå°†ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼Œè¯·å‹¿æ³„éœ²</p>
          </div>
          <button
            onclick="saveApiKey()"
            class="w-full bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-700 hover:to-teal-700 text-white font-medium py-2 px-4 rounded-lg transition-all"
          >
            ä¿å­˜é…ç½®
          </button>
          <button
            onclick="hideApiKeyConfig()"
            class="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium py-2 px-4 rounded-lg transition-all"
          >
            å–æ¶ˆ
          </button>
        </div>
      </div>
    </div>

    <!-- æ–°é—»å…¨æ–‡å¼¹çª— -->
    <div id="newsDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.8);" onclick="hideNewsDetail()">
      <div class="bg-slate-800 rounded-xl p-6 max-w-2xl w-full mx-4 border border-slate-700 shadow-2xl max-h-[85vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-white" id="newsDetailTitle">æ–°é—»æ ‡é¢˜</h3>
          <button onclick="hideNewsDetail()" class="text-slate-400 hover:text-white text-2xl">&times;</button>
        </div>
        <div class="space-y-4">
          <div class="flex items-center gap-2 flex-wrap text-sm">
            <span id="newsDetailTime" class="text-slate-400">å‘å¸ƒæ—¶é—´</span>
            <span id="newsDetailSource" class="px-2 py-1 bg-emerald-500/20 text-emerald-300 rounded-md font-medium">æ¥æº</span>
          </div>
          <div id="newsDetailContent" class="text-slate-300 text-sm leading-relaxed whitespace-pre-wrap">
            æ–°é—»å†…å®¹
          </div>
          <div id="newsDetailTags" class="flex items-center gap-2 flex-wrap text-xs">
          </div>
          <button
            onclick="hideNewsDetail()"
            class="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium py-2 px-4 rounded-lg transition-all mt-4"
          >
            å…³é—­
          </button>
        </div>
      </div>
    </div>

    <!-- å¸ç§è¯¦æƒ…å¼¹çª— -->
    <div id="coinDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.8);" onclick="hideCoinDetail()">
      <div class="bg-slate-800 rounded-xl p-6 max-w-4xl w-full mx-4 border border-slate-700 shadow-2xl max-h-[85vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-white">å¸ç§è¯¦æƒ…</h3>
          <button onclick="hideCoinDetail()" class="text-slate-400 hover:text-white text-2xl">&times;</button>
        </div>

        <!-- å¸ç§ä¿¡æ¯å¤´éƒ¨ -->
        <div id="coinDetailHeader" class="flex items-center gap-4 mb-6">
          <div class="flex-1">
            <div id="coinDetailName" class="text-2xl font-bold text-white">å¸ç§åç§°</div>
            <div id="coinDetailBadges" class="flex gap-2 mt-1 text-sm">
            </div>
          </div>
          <div class="text-right">
            <div id="coinDetailPrice" class="text-2xl font-bold text-white">$0.00</div>
            <div id="coinDetailChange" class="text-sm">0.00%</div>
          </div>
        </div>

        <!-- å¸ç§ç®€ä»‹ -->
        <div id="coinDetailDescSection" class="mb-6">
          <h3 class="font-bold text-sm mb-2 text-slate-300">ğŸ’¡ å¸ç§ç®€ä»‹</h3>
          <p id="coinDetailDesc" class="text-slate-300 text-sm leading-relaxed line-clamp-3">
            åŠ è½½ä¸­...
          </p>
          <button id="coinDetailDescToggle" onclick="toggleCoinDetailDesc()" class="text-xs text-emerald-400 mt-1 hover:text-emerald-300">å±•å¼€å…¨éƒ¨ â†“</button>
        </div>

        <!-- å…³é”®æŒ‡æ ‡ -->
        <div id="coinDetailMetricsSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ“Š å…³é”®æŒ‡æ ‡</h3>
          <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">å¸‚å€¼</div>
              <div id="coinDetailMarketCap" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">æµé€šä¾›åº”é‡</div>
              <div id="coinDetailSupply" class="text-white font-bold">0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">æ€»ä¾›åº”é‡</div>
              <div id="coinDetailTotalSupply" class="text-white font-bold">0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">æœ€å¤§ä¾›åº”é‡</div>
              <div id="coinDetailMaxSupply" class="text-white font-bold">0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">24häº¤æ˜“é‡</div>
              <div id="coinDetailVolume" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">æœ€é«˜ä»·ï¼ˆATHï¼‰</div>
              <div id="coinDetailATH" class="text-white font-bold">$0.00</div>
            </div>
          </div>
        </div>

        <!-- ä»·æ ¼å˜åŒ–æ•°æ® -->
        <div id="coinDetailPriceChangeSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ’¹ ä»·æ ¼å˜åŒ–</h3>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">1å°æ—¶</div>
              <div id="coinDetailChange1h" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">24å°æ—¶</div>
              <div id="coinDetailChange24h" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">7å¤©</div>
              <div id="coinDetailChange7d" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">30å¤©</div>
              <div id="coinDetailChange30d" class="text-white font-bold">0.00%</div>
            </div>
          </div>
        </div>

        <!-- å…¶ä»–æŒ‡æ ‡ -->
        <div id="coinDetailOtherSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ” å…¶ä»–æŒ‡æ ‡</h3>
          <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">å†å²æœ€é«˜ä»·æ—¥æœŸ</div>
              <div id="coinDetailATHDate" class="text-white font-bold text-xs">--</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">ä»ATHä¸‹è·Œ</div>
              <div id="coinDetailATHChange" class="text-orange-400 font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">å†å²æœ€ä½ä»·ï¼ˆATLï¼‰</div>
              <div id="coinDetailATL" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">å†å²æœ€ä½ä»·æ—¥æœŸ</div>
              <div id="coinDetailATLDate" class="text-white font-bold text-xs">--</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">ä»ATLä¸Šæ¶¨</div>
              <div id="coinDetailATLChange" class="text-green-400 font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">å®Œå…¨ç¨€é‡Šä¼°å€¼</div>
              <div id="coinDetailFullyDilutedValuation" class="text-white font-bold">$0.00</div>
            </div>
          </div>
        </div>

        <!-- å¤–éƒ¨é“¾æ¥ -->
        <div id="coinDetailLinksSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸŒ å¤–éƒ¨é“¾æ¥</h3>
          <div class="flex flex-wrap gap-2" id="coinDetailLinks">
            <a id="coinDetailTwitter" href="#" target="_blank" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-slate-300 text-sm rounded-lg transition-all">
              Twitter/X â†—
            </a>
            <a id="coinDetailGecko" href="#" target="_blank" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-slate-300 text-sm rounded-lg transition-all">
              CoinGecko â†—
            </a>
          </div>
        </div>

        <!-- å…³é—­æŒ‰é’® -->
        <button onclick="hideCoinDetail()" class="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium py-2 px-4 rounded-lg transition-all">
          å…³é—­
        </button>
      </div>
    </div>

    <!-- æ± å­è¯¦æƒ…å¼¹çª— -->
    <div id="poolDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.8);" onclick="hidePoolDetail()">
      <div class="bg-slate-800 rounded-xl p-6 max-w-4xl w-full mx-4 border border-slate-700 shadow-2xl max-h-[85vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-white">æ± å­è¯¦æƒ…</h3>
          <button onclick="hidePoolDetail()" class="text-slate-400 hover:text-white text-2xl">&times;</button>
        </div>

        <!-- æ± å­ä¿¡æ¯å¤´éƒ¨ -->
        <div id="poolDetailHeader" class="flex items-center gap-4 mb-6">
          <div class="flex-1">
            <div id="poolDetailName" class="text-2xl font-bold text-white">æ± å­åç§°</div>
            <div id="poolDetailBadges" class="flex gap-2 mt-1 text-sm">
            </div>
          </div>
          <div class="text-right">
            <div id="poolDetailTVL" class="text-2xl font-bold text-emerald-400">$0.00</div>
            <div class="text-slate-400 text-sm mt-1">TVL</div>
          </div>
        </div>

        <!-- äº¤æ˜“å¯¹ä¿¡æ¯ -->
        <div id="poolDetailPairSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ’± äº¤æ˜“å¯¹</h3>
          <div class="grid grid-cols-2 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">åŸºç¡€ä»£å¸</div>
              <div id="poolDetailBaseToken" class="text-white font-bold">--</div>
              <div id="poolDetailBaseTokenAddress" class="text-slate-400 text-xs mt-1 break-all">--</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">æŠ¥ä»·ä»£å¸</div>
              <div id="poolDetailQuoteToken" class="text-white font-bold">--</div>
              <div id="poolDetailQuoteTokenAddress" class="text-slate-400 text-xs mt-1 break-all">--</div>
            </div>
          </div>
        </div>

        <!-- å…³é”®æŒ‡æ ‡ -->
        <div id="poolDetailMetricsSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ“Š å…³é”®æŒ‡æ ‡</h3>
          <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">TVL</div>
              <div id="poolDetailTVLMetric" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">24häº¤æ˜“é‡</div>
              <div id="poolDetailVolume24h" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">24häº¤æ˜“æ¬¡æ•°</div>
              <div id="poolDetailTxCount" class="text-white font-bold">0</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">äº¤æ˜“ä»·æ ¼</div>
              <div id="poolDetailPrice" class="text-white font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">DEXå¹³å°</div>
              <div id="poolDetailDex" class="text-white font-bold">--</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">ç½‘ç»œ</div>
              <div id="poolDetailNetwork" class="text-white font-bold">--</div>
            </div>
          </div>
        </div>

        <!-- æ± å­åœ°å€ -->
        <div id="poolDetailAddressSection" class="mb-6">
          <h3 class="font-bold text-sm mb-2 text-slate-300">ğŸ”— æ± å­åœ°å€</h3>
          <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
            <div id="poolDetailAddress" class="text-emerald-400 text-xs break-all">--</div>
          </div>
        </div>

        <!-- ä»·æ ¼å˜åŒ–æ•°æ® -->
        <div id="poolDetailPriceChangeSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸ’¹ ä»·æ ¼å˜åŒ–</h3>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">1å°æ—¶</div>
              <div id="poolDetailChange1h" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">6å°æ—¶</div>
              <div id="poolDetailChange6h" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">24å°æ—¶</div>
              <div id="poolDetailChange24h" class="text-white font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-700/50 rounded-lg border border-slate-600">
              <div class="text-slate-400 text-xs mb-1">7å¤©</div>
              <div id="poolDetailChange7d" class="text-white font-bold">0.00%</div>
            </div>
          </div>
        </div>

        <!-- å¤–éƒ¨é“¾æ¥ -->
        <div id="poolDetailLinksSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-300">ğŸŒ å¤–éƒ¨é“¾æ¥</h3>
          <div class="flex flex-wrap gap-2">
            <a id="poolDetailTwitter" href="#" target="_blank" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-slate-300 text-sm rounded-lg transition-all">
              Twitter/X â†—
            </a>
            <a id="poolDetailGeckoTerminal" href="#" target="_blank" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-slate-300 text-sm rounded-lg transition-all">
              GeckoTerminal â†—
            </a>
            <a id="poolDetailDexscreener" href="#" target="_blank" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-slate-300 text-sm rounded-lg transition-all">
              Dexscreener â†—
            </a>
          </div>
        </div>

        <!-- å…³é—­æŒ‰é’® -->
        <button onclick="hidePoolDetail()" class="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium py-2 px-4 rounded-lg transition-all">
          å…³é—­
        </button>
      </div>
    </div>
  </div>

  <script>
    // ==================== API Key é…ç½® ====================
    // é»˜è®¤API Keyï¼ˆä»Followin Open APIæ–‡æ¡£ä¸­æå–ï¼‰
    const DEFAULT_API_KEY = 'p0JNCcX8rGkEsi6hb883iDWyPGsNY6WK';
    let FOLLOWIN_API_KEY = '';

    // ==================== æ··åˆAPIé…ç½®ï¼ˆ2026å¹´æ¨èæ–¹æ¡ˆï¼‰====================
    // ä½¿ç”¨CryptoCompareè·å–ä¸»è¦æ•°æ®ï¼ˆå…è´¹é¢åº¦25ä¸‡/æœˆï¼‰
    // ä½¿ç”¨Coinloreè·å–çƒ­é—¨ä»£å¸ï¼ˆå…è´¹æ— é™ï¼Œæ— éœ€API Keyï¼‰
    // æè´ªæŒ‡æ•°ç»§ç»­ä½¿ç”¨Alternative.me
    
    const CRYPTOCOMPARE_API_KEY = '40956b76e16893009725907be2b0905549daf86ab8c3d13d34e0e56898aa7970'; // CryptoCompare API Keyï¼ˆæ¯æœˆ25ä¸‡æ¬¡å…è´¹è°ƒç”¨ï¼‰
    const COINLORE_API_URL = 'https://api.coinlore.net/api';
    const CRYPTOCOMPARE_API_URL = 'https://min-api.cryptocompare.com/data';
    const FEAR_GREED_API_URL = 'https://api.alternative.me/fng';

    // APIé…ç½®çŠ¶æ€
    const API_CONFIG = {
      useCryptoCompare: true,    // ä½¿ç”¨CryptoCompareè·å–BTC/ETHä»·æ ¼å’Œå…¨çƒæ•°æ®
      useCoinlore: true,          // ä½¿ç”¨Coinloreè·å–çƒ­é—¨ä»£å¸
      useAlternative: true,       // ä½¿ç”¨Alternative.meè·å–æè´ªæŒ‡æ•°
      cryptoCompareKey: CRYPTOCOMPARE_API_KEY
    };

    // ä»localStorageåŠ è½½API Keyï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
    function loadApiKey() {
      const savedKey = localStorage.getItem('followin_api_key');
      if (savedKey) {
        FOLLOWIN_API_KEY = savedKey;
        addLog('info', 'å·²åŠ è½½ä¿å­˜çš„API Key');
      } else {
        // ä½¿ç”¨é»˜è®¤API Key
        FOLLOWIN_API_KEY = DEFAULT_API_KEY;
        addLog('success', 'ä½¿ç”¨é»˜è®¤API Key');
      }
      return FOLLOWIN_API_KEY;
    }

    // æ˜¾ç¤ºAPI Keyé…ç½®æ¨¡æ€æ¡†
    function showApiKeyConfig() {
      const modal = document.getElementById('apiKeyModal');
      const input = document.getElementById('apiKeyInput');
      input.value = FOLLOWIN_API_KEY || DEFAULT_API_KEY;
      modal.classList.remove('hidden');
    }

    // éšè—API Keyé…ç½®æ¨¡æ€æ¡†
    function hideApiKeyConfig() {
      const modal = document.getElementById('apiKeyModal');
      modal.classList.add('hidden');
    }

    // ä½¿ç”¨é»˜è®¤API Key
    function useDefaultApiKey() {
      const input = document.getElementById('apiKeyInput');
      input.value = DEFAULT_API_KEY;
      addLog('info', 'å·²å¡«å…¥é»˜è®¤API Key');
    }

    // ä¿å­˜API Key
    function saveApiKey() {
      const input = document.getElementById('apiKeyInput');
      const apiKey = input.value.trim();

      if (!apiKey) {
        alert('è¯·è¾“å…¥API Key');
        return;
      }

      FOLLOWIN_API_KEY = apiKey;
      localStorage.setItem('followin_api_key', apiKey);
      addLog('success', 'API Keyå·²ä¿å­˜');
      hideApiKeyConfig();

      // è‡ªåŠ¨åˆ·æ–°æ–°é—»æ•°æ®
      refreshNewsData();
    }

    // ==================== å…¨å±€ç¼“å­˜å˜é‡ ====================
    // æ³¨æ„ï¼šè¿™äº›ç¼“å­˜å˜é‡å®šä¹‰åœ¨æ‰€æœ‰å‡½æ•°ä¹‹å‰ï¼Œé¿å…å˜é‡æœªå®šä¹‰é”™è¯¯

    // Kçº¿æ•°æ®ç¼“å­˜ (symbol -> { data: [], timestamp: number })
    const klineCache = new Map();

    // å¸ç§è¯¦æƒ…æ•°æ®ç¼“å­˜ (symbol -> { coinGecko: {}, volume: {}, timestamp: number })
    const coinDetailCache = new Map();

    // CoinGecko IDæœç´¢ç¼“å­˜ (symbol -> coinId)
    const coinIdCache = new Map();

    // æ± å­è¯¦æƒ…ç¼“å­˜
    let poolDetailCache = {};

    // ==================== æ–°é—»å…¨æ–‡å¼¹çª— ====================
    function showNewsDetail(item, type) {
      const modal = document.getElementById('newsDetailModal');
      const titleEl = document.getElementById('newsDetailTitle');
      const timeEl = document.getElementById('newsDetailTime');
      const sourceEl = document.getElementById('newsDetailSource');
      const contentEl = document.getElementById('newsDetailContent');
      const tagsEl = document.getElementById('newsDetailTags');

      // è®¾ç½®æ ‡é¢˜
      titleEl.textContent = item.title || 'æ— æ ‡é¢˜';

      // è®¾ç½®å‘å¸ƒæ—¶é—´
      timeEl.textContent = `å‘å¸ƒæ—¶é—´: ${formatPublishTime(item.publish_time)}`;

      // è®¾ç½®æ¥æº/ä½œè€…
      let sourceText = '';
      let sourceClass = '';
      if (type === 'hot' && item.source_name) {
        sourceText = item.source_name;
        sourceClass = 'bg-orange-500/20 text-orange-300';
      } else if (type === 'latest' && item.nickname) {
        sourceText = item.nickname;
        sourceClass = 'bg-emerald-500/20 text-emerald-300';
      } else if (type === 'kol' && item.nickname) {
        sourceText = item.nickname;
        sourceClass = 'bg-amber-500/20 text-amber-300';
      } else if (type === 'trending') {
        sourceText = 'çƒ­é—¨è¶‹åŠ¿';
        sourceClass = 'bg-emerald-500/20 text-emerald-300';
      } else {
        sourceText = 'æœªçŸ¥æ¥æº';
        sourceClass = 'bg-slate-500/20 text-slate-300';
      }
      sourceEl.textContent = sourceText;
      sourceEl.className = `px-2 py-1 rounded-md font-medium ${sourceClass}`;

      // è®¾ç½®å†…å®¹
      contentEl.textContent = item.content || 'æš‚æ— å†…å®¹';

      // è®¾ç½®æ ‡ç­¾
      if (item.tags && item.tags.length > 0) {
        tagsEl.innerHTML = item.tags.slice(0, 5).map(tag => `
          <span class="px-2 py-1 bg-slate-700 text-slate-300 rounded-md">${tag.symbol || tag.name || tag}</span>
        `).join('');
      } else {
        tagsEl.innerHTML = '';
      }

      // æ˜¾ç¤ºå¼¹çª—
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden'; // ç¦æ­¢èƒŒæ™¯æ»šåŠ¨
    }

    function hideNewsDetail() {
      const modal = document.getElementById('newsDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== å¸ç§è¯¦æƒ…å¼¹çª— ====================

    // æ ¼å¼åŒ–å¤§æ•°å­—
    function formatLargeNumber(num) {
      if (num >= 1000000000000) {
        return `$${(num / 1000000000000).toFixed(2)}T`;
      } else if (num >= 1000000000) {
        return `$${(num / 1000000000).toFixed(2)}B`;
      } else if (num >= 1000000) {
        return `$${(num / 1000000).toFixed(2)}M`;
      } else if (num >= 1000) {
        return `$${(num / 1000).toFixed(2)}K`;
      } else {
        return `$${num.toFixed(2)}`;
      }
    }

    // æ ¼å¼åŒ–ä¾›åº”é‡
    function formatSupply(num) {
      if (num >= 1000000000) {
        return `${(num / 1000000000).toFixed(2)}B`;
      } else if (num >= 1000000) {
        return `${(num / 1000000).toFixed(2)}M`;
      } else {
        return `${num.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
      }
    }

    // å±•å¼€/æ”¶èµ·å¸ç§ç®€ä»‹
    function toggleCoinDetailDesc() {
      const descEl = document.getElementById('coinDetailDesc');
      const toggleBtn = document.getElementById('coinDetailDescToggle');
      
      if (descEl.classList.contains('line-clamp-3')) {
        descEl.classList.remove('line-clamp-3');
        toggleBtn.textContent = 'æ”¶èµ· â†‘';
      } else {
        descEl.classList.add('line-clamp-3');
        toggleBtn.textContent = 'å±•å¼€å…¨éƒ¨ â†“';
      }
    }

    // æ˜¾ç¤ºå¸ç§è¯¦æƒ…å¼¹çª—
    async function showCoinDetail(symbol) {
      const modal = document.getElementById('coinDetailModal');
      
      // é‡ç½®å¼¹çª—å†…å®¹
      document.getElementById('coinDetailName').innerHTML = symbol;
      document.getElementById('coinDetailBadges').innerHTML = '';
      document.getElementById('coinDetailPrice').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailDesc').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailMarketCap').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailSupply').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailTotalSupply').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailMaxSupply').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailVolume').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailATH').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailFullyDilutedValuation').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange1h').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange24h').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange7d').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange30d').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailATHDate').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailATHChange').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailATL').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailATLDate').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailATLChange').textContent = 'åŠ è½½ä¸­...';

      // æ˜¾ç¤ºå¼¹çª—
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';

      // æ£€æŸ¥ç¼“å­˜
      let cachedData = coinDetailCache.get(symbol);

      if (!cachedData) {
        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œè·å–æ•°æ®
        addLog('info', 'ç¼“å­˜æœªå‘½ä¸­ï¼Œè·å– ' + symbol + ' å¸ç§è¯¦æƒ…æ•°æ®...');
        
        // åªè·å–CoinGeckoæ•°æ®
        const coinGeckoInfo = await fetchCoinGeckoInfo(symbol);

        // å¦‚æœè·å–æˆåŠŸï¼Œç¼“å­˜å¹¶æ˜¾ç¤ºæ•°æ®
        if (coinGeckoInfo) {
          cachedData = {
            coinGecko: coinGeckoInfo,
            volume: null,
            timestamp: Date.now()
          };
          coinDetailCache.set(symbol, cachedData);
          addLog('success', symbol + ' å¸ç§è¯¦æƒ…æ•°æ®è·å–å®Œæˆ');
        } else {
          // è·å–å¤±è´¥ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
          addLog('error', symbol + ' å¸ç§è¯¦æƒ…æ•°æ®è·å–å¤±è´¥');
          document.getElementById('coinDetailDesc').textContent = 'æ•°æ®è·å–å¤±è´¥ï¼Œè¯¥å¸ç§å¯èƒ½ä¸åœ¨CoinGeckoåˆ—è¡¨ä¸­ï¼Œè¯·ç¨åé‡è¯•';
          document.getElementById('coinDetailPrice').textContent = 'N/A';
          document.getElementById('coinDetailMarketCap').textContent = 'N/A';
          document.getElementById('coinDetailSupply').textContent = 'N/A';
          return;
        }
      } else {
        addLog('info', 'ç¼“å­˜å‘½ä¸­ï¼Œä½¿ç”¨ ' + symbol + ' å¸ç§è¯¦æƒ…æ•°æ®');
      }

      // æ›´æ–°å¼¹çª—å†…å®¹
      updateCoinDetailModal(symbol, cachedData);
    }

    // ==================== è¾…åŠ©å‡½æ•° ====================
    
    // æ ¼å¼åŒ–ä»·æ ¼å˜åŒ–
    function formatPriceChange(value) {
      if (value === null || value === undefined || isNaN(value)) {
        return '0.00%';
      }
      const sign = value >= 0 ? '+' : '';
      return sign + value.toFixed(2) + '%';
    }

    // è·å–Twitteræœç´¢URL
    function getTwitterSearchUrl(symbol) {
      return `https://x.com/search?q=%24${symbol}&src=cashtag_click`;
    }
    
    // æ›´æ–°ä»·æ ¼å˜åŒ–å…ƒç´ 
    function updatePriceChange(elementId, value) {
      const el = document.getElementById(elementId);
      if (!el) return;
      
      const val = parseFloat(value) || 0;
      const text = formatPriceChange(val);
      
      el.textContent = text;
      el.className = 'text-white font-bold ' + (val >= 0 ? 'text-green-400' : 'text-orange-400');
    }

    // æ›´æ–°å¸ç§è¯¦æƒ…å¼¹çª—å†…å®¹
    function updateCoinDetailModal(symbol, data) {
      const coinGecko = data.coinGecko;
      const volume = data.volume;

      // æå‰å£°æ˜twitterUrlï¼Œä½¿å…¶åœ¨æ•´ä¸ªå‡½æ•°ä½œç”¨åŸŸä¸­å¯ç”¨
      let twitterUrl;

      // æ›´æ–°å¸ç§ä¿¡æ¯å¤´éƒ¨
      if (coinGecko) {
        twitterUrl = getTwitterSearchUrl(coinGecko.symbol || symbol);
        document.getElementById('coinDetailName').innerHTML = `
          <a href="${twitterUrl}" target="_blank" class="hover:text-emerald-400 transition-colors flex items-center gap-2">
            ${coinGecko.name} (${coinGecko.symbol.toUpperCase()})
            <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
          </a>
        `;

        // æ·»åŠ æ ‡ç­¾
        let badgesHTML = '';
        if (coinGecko.marketCapRank && coinGecko.marketCapRank !== 'N/A') {
          badgesHTML += '<span class="px-2 py-1 bg-emerald-500/20 text-emerald-300 rounded">å¸‚å€¼æ’å #' + coinGecko.marketCapRank + '</span>';
        }
        if (coinGecko.categories && coinGecko.categories.length > 0) {
          badgesHTML += coinGecko.categories.slice(0, 2).map(function(cat) {
            return '<span class="px-2 py-1 bg-slate-500/20 text-slate-300 rounded">' + cat + '</span>';
          }).join('');
        }
        document.getElementById('coinDetailBadges').innerHTML = badgesHTML;

        // æ›´æ–°ä»·æ ¼å’Œæ¶¨è·Œ
        document.getElementById('coinDetailPrice').textContent = formatLargeNumber(coinGecko.currentPrice.usd);
        const changeEl = document.getElementById('coinDetailChange');
        const change = coinGecko.priceChange24h;
        changeEl.textContent = (change >= 0 ? '' : '') + change.toFixed(2) + '%';
        changeEl.className = 'text-sm ' + (change >= 0 ? 'text-green-400' : 'text-orange-400');

        // æ›´æ–°ç®€ä»‹ï¼ˆä¼˜å…ˆæ˜¾ç¤ºä¸­æ–‡ï¼‰
        let description = 'æš‚æ— æè¿°';
        if (coinGecko.description) {
          // CoinGecko APIè¿”å›çš„å¤šè¯­è¨€æè¿°ï¼šzh=ä¸­æ–‡, en=è‹±æ–‡ç­‰
          description = coinGecko.description.zh || 
                       coinGecko.description.en || 
                       coinGecko.description.tr || 
                       coinGecko.description.ru || 
                       coinGecko.description.ja || 
                       Object.values(coinGecko.description)[0] || 
                       'æš‚æ— æè¿°';
        }
        // é™åˆ¶é•¿åº¦å¹¶æ·»åŠ çœç•¥å·
        const descText = description.length > 500 ? description.substring(0, 500) + '...' : description;
        document.getElementById('coinDetailDesc').textContent = descText;

        // æ›´æ–°å…³é”®æŒ‡æ ‡
        document.getElementById('coinDetailMarketCap').textContent = formatLargeNumber(coinGecko.marketCap.usd);
        document.getElementById('coinDetailSupply').textContent = formatSupply(coinGecko.circulatingSupply);
        document.getElementById('coinDetailTotalSupply').textContent = formatSupply(coinGecko.totalSupply);
        document.getElementById('coinDetailMaxSupply').textContent = formatSupply(coinGecko.maxSupply);
        document.getElementById('coinDetailVolume').textContent = formatLargeNumber(coinGecko.totalVolume.usd);
        document.getElementById('coinDetailATH').textContent = formatLargeNumber(coinGecko.ath.usd);
        document.getElementById('coinDetailFullyDilutedValuation').textContent = formatLargeNumber(coinGecko.fullyDilutedValuation);

        // æ›´æ–°ä»·æ ¼å˜åŒ–
        const updatePriceChange = function(elementId, value) {
          var el = document.getElementById(elementId);
          var val = value || 0;
          el.textContent = (val >= 0 ? '+' : '') + val.toFixed(2) + '%';
          el.className = 'text-white font-bold ' + (val >= 0 ? 'text-green-400' : 'text-orange-400');
        };

        updatePriceChange('coinDetailChange1h', coinGecko.priceChange1h);
        updatePriceChange('coinDetailChange24h', coinGecko.priceChange24h);
        updatePriceChange('coinDetailChange7d', coinGecko.priceChange7d);
        updatePriceChange('coinDetailChange30d', coinGecko.priceChange30d);

        // æ›´æ–°å…¶ä»–æŒ‡æ ‡
        document.getElementById('coinDetailATHDate').textContent = coinGecko.ath.date ? coinGecko.ath.date.substring(0, 10) : 'N/A';
        var athChange = coinGecko.ath.changePercentage || 0;
        document.getElementById('coinDetailATHChange').textContent = athChange.toFixed(2) + '%';
        document.getElementById('coinDetailATHChange').className = 'text-orange-400 font-bold';

        document.getElementById('coinDetailATL').textContent = formatLargeNumber(coinGecko.atl.usd);
        document.getElementById('coinDetailATLDate').textContent = coinGecko.atl.date ? coinGecko.atl.date.substring(0, 10) : 'N/A';
        var atlChange = coinGecko.atl.changePercentage || 0;
        document.getElementById('coinDetailATLChange').textContent = atlChange.toFixed(2) + '%';
        document.getElementById('coinDetailATLChange').className = 'text-green-400 font-bold';

        // æ›´æ–°å¤–éƒ¨é“¾æ¥
        const coinSymbol = coinGecko.symbol || symbol.replace('USDT', '').replace('BUSD', '');
        // twitterUrlå·²åœ¨å‰é¢å£°æ˜ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨
        document.getElementById('coinDetailTwitter').href = twitterUrl;
        if (coinGecko.links && coinGecko.links.homepage && coinGecko.links.homepage[0]) {
          document.getElementById('coinDetailGecko').href = coinGecko.links.homepage[0];
        }
      } else {
        // æ²¡æœ‰CoinGeckoæ•°æ®ï¼Œæ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
        twitterUrl = getTwitterSearchUrl(symbol);
        const coinSymbol = symbol.replace('USDT', '');
        document.getElementById('coinDetailName').innerHTML = `
          <a href="${twitterUrl}" target="_blank" class="hover:text-emerald-400 transition-colors flex items-center gap-2">
            ${coinSymbol}
            <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
          </a>
        `;
        document.getElementById('coinDetailBadges').innerHTML = '<span class="px-2 py-1 bg-yellow-500/20 text-yellow-300 rounded">æ•°æ®è·å–å¤±è´¥</span>';
        document.getElementById('coinDetailPrice').textContent = 'N/A';
        document.getElementById('coinDetailChange').textContent = 'N/A';
        document.getElementById('coinDetailDesc').textContent = 'è¯¥å¸ç§çš„åŸºæœ¬ä¿¡æ¯æš‚æ— æ³•è·å–ï¼Œå¯èƒ½æ˜¯ç”±äºCoinGecko APIé™æµæˆ–è¯¥å¸ç§æœªè¢«æ”¶å½•ã€‚';
        document.getElementById('coinDetailMarketCap').textContent = 'N/A';
        document.getElementById('coinDetailSupply').textContent = 'N/A';
        document.getElementById('coinDetailVolume').textContent = 'N/A';
        document.getElementById('coinDetailATH').textContent = 'N/A';
      }
    }

    // éšè—å¸ç§è¯¦æƒ…å¼¹çª—
    function hideCoinDetail() {
      const modal = document.getElementById('coinDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== æ± å­è¯¦æƒ…ç³»ç»Ÿ ====================

    // æ˜¾ç¤ºæ± å­è¯¦æƒ…å¼¹çª—
    async function showPoolDetail(poolAddress, baseTokenAddress, network) {
      const modal = document.getElementById('poolDetailModal');

      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = `${network}-${poolAddress}`;
      if (poolDetailCache[cacheKey]) {
        updatePoolDetailModal(poolDetailCache[cacheKey]);
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        return;
      }

      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      document.getElementById('poolDetailName').innerHTML = 'åŠ è½½ä¸­...';
      document.getElementById('poolDetailTVL').innerHTML = '--';

      try {
        // è·å–æ± å­è¯¦æƒ…
        const apiUrl = `https://api.geckoterminal.com/api/v2/networks/${network}/pools/${poolAddress}`;

        const response = await fetchWithRetry(apiUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false);

        if (!response.ok) {
          throw new Error(`APIè¿”å›é”™è¯¯: ${response.status}`);
        }

        const json = await response.json();

        if (!json || !json.data) {
          throw new Error('æ•°æ®ä¸ºç©º');
        }

        const poolData = json.data;
        const attributes = poolData.attributes;

        // ä¿å­˜åˆ°ç¼“å­˜
        poolDetailCache[cacheKey] = {
          network,
          poolAddress,
          baseTokenAddress,
          attributes
        };

        // æ›´æ–°å¼¹çª—å†…å®¹
        updatePoolDetailModal(poolDetailCache[cacheKey]);

        addLog('success', `æ± å­è¯¦æƒ…å·²åŠ è½½: ${attributes.name}`);
      } catch (error) {
        addLog('error', 'æ± å­è¯¦æƒ…è·å–å¤±è´¥', error.message);
        
        // æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯å’Œå¤–éƒ¨é“¾æ¥ï¼ˆå³ä½¿APIå¤±è´¥ï¼‰
        const baseTokenSymbol = poolAddress.substring(0, 6);
        const twitterUrl = getTwitterSearchUrl(baseTokenSymbol);
        const geckoTerminalUrl = `https://www.geckoterminal.com/${network}/pools/${poolAddress}`;
        const dexscreenerUrl = `https://dexscreener.com/${network}/${poolAddress}`;
        
        document.getElementById('poolDetailName').innerHTML = `æ± å­è¯¦æƒ… (æ•°æ®è·å–å¤±è´¥)`;
        document.getElementById('poolDetailTVL').innerHTML = '--';
        document.getElementById('poolDetailBaseToken').innerHTML = baseTokenSymbol;
        document.getElementById('poolDetailQuoteToken').innerHTML = '--';
        document.getElementById('poolDetailTVLMetric').innerHTML = '--';
        document.getElementById('poolDetailVolume24h').innerHTML = '--';
        document.getElementById('poolDetailPrice').innerHTML = '--';
        document.getElementById('poolDetailDex').innerHTML = network.toUpperCase();
        document.getElementById('poolDetailNetwork').innerHTML = network.toUpperCase();
        document.getElementById('poolDetailAddress').innerHTML = poolAddress;
        document.getElementById('poolDetailTwitter').href = twitterUrl;
        document.getElementById('poolDetailGeckoTerminal').href = geckoTerminalUrl;
        document.getElementById('poolDetailDexscreener').href = dexscreenerUrl;
        
        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
        document.getElementById('poolDetailBadges').innerHTML =
          '<span class="bg-orange-500/20 text-orange-400 px-2 py-1 rounded text-xs">æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·é€šè¿‡å¤–éƒ¨é“¾æ¥æŸ¥çœ‹</span>';
      }
    }

    // æ›´æ–°æ± å­è¯¦æƒ…å¼¹çª—å†…å®¹
    function updatePoolDetailModal(data) {
      const { network, poolAddress, baseTokenAddress, attributes } = data;

      // æ± å­ä¿¡æ¯å¤´éƒ¨
      document.getElementById('poolDetailName').innerHTML = attributes.name || 'æœªçŸ¥æ± å­';
      document.getElementById('poolDetailTVL').innerHTML = formatNumber(attributes.reserve_in_usd || 0, 'USD', 2);

      // å¾½ç« 
      const badgesHtml = [
        `<span class="bg-emerald-500/20 text-emerald-400 px-2 py-1 rounded text-xs">${network.toUpperCase()}</span>`,
        `<span class="bg-slate-500/20 text-slate-400 px-2 py-1 rounded text-xs">${attributes.dex?.name || 'Unknown'}</span>`,
        attributes.is_verified ? '<span class="bg-green-500/20 text-green-400 px-2 py-1 rounded text-xs">âœ“ å·²éªŒè¯</span>' : ''
      ].filter(Boolean).join('');
      document.getElementById('poolDetailBadges').innerHTML = badgesHtml;

      // äº¤æ˜“å¯¹ä¿¡æ¯
      document.getElementById('poolDetailBaseToken').innerHTML = attributes.base_token?.symbol || '--';
      document.getElementById('poolDetailBaseTokenAddress').innerHTML = attributes.base_token?.address || '--';
      document.getElementById('poolDetailQuoteToken').innerHTML = attributes.quote_token?.symbol || '--';
      document.getElementById('poolDetailQuoteTokenAddress').innerHTML = attributes.quote_token?.address || '--';

      // å…³é”®æŒ‡æ ‡
      document.getElementById('poolDetailTVLMetric').innerHTML = formatNumber(attributes.reserve_in_usd || 0, 'USD', 2);
      document.getElementById('poolDetailVolume24h').innerHTML = formatNumber(attributes.volume_usd?.h24 || 0, 'USD', 2);
      document.getElementById('poolDetailTxCount').innerHTML = formatNumber(attributes.tx_count?.h24 || 0, 'number', 0);
      document.getElementById('poolDetailPrice').innerHTML = formatNumber(attributes.base_token_price_usd || 0, 'USD', 6);
      document.getElementById('poolDetailDex').innerHTML = attributes.dex?.name || '--';
      document.getElementById('poolDetailNetwork').innerHTML = network.toUpperCase();

      // æ± å­åœ°å€
      document.getElementById('poolDetailAddress').innerHTML = poolAddress;

      // ä»·æ ¼å˜åŒ–æ•°æ®
      const change1h = attributes.price_change_percentage?.h1 || 0;
      const change6h = attributes.price_change_percentage?.h6 || 0;
      const change24h = attributes.price_change_percentage?.h24 || 0;
      const change7d = attributes.price_change_percentage?.d7 || 0;

      document.getElementById('poolDetailChange1h').innerHTML = formatPriceChange(change1h);
      document.getElementById('poolDetailChange1h').className = `font-bold ${change1h >= 0 ? 'text-green-400' : 'text-orange-400'}`;

      document.getElementById('poolDetailChange6h').innerHTML = formatPriceChange(change6h);
      document.getElementById('poolDetailChange6h').className = `font-bold ${change6h >= 0 ? 'text-green-400' : 'text-orange-400'}`;

      document.getElementById('poolDetailChange24h').innerHTML = formatPriceChange(change24h);
      document.getElementById('poolDetailChange24h').className = `font-bold ${change24h >= 0 ? 'text-green-400' : 'text-orange-400'}`;

      document.getElementById('poolDetailChange7d').innerHTML = formatPriceChange(change7d);
      document.getElementById('poolDetailChange7d').className = `font-bold ${change7d >= 0 ? 'text-green-400' : 'text-orange-400'}`;

      // å¤–éƒ¨é“¾æ¥
      const baseTokenSymbol = attributes.base_token?.symbol || '';
      const geckoTerminalUrl = `https://www.geckoterminal.com/${network}/pools/${poolAddress}`;
      const dexscreenerUrl = `https://dexscreener.com/${network}/${poolAddress}`;
      const twitterUrl = baseTokenSymbol ? getTwitterSearchUrl(baseTokenSymbol) : '#';

      document.getElementById('poolDetailTwitter').href = twitterUrl;
      document.getElementById('poolDetailGeckoTerminal').href = geckoTerminalUrl;
      document.getElementById('poolDetailDexscreener').href = dexscreenerUrl;
    }

    // éšè—æ± å­è¯¦æƒ…å¼¹çª—
    function hidePoolDetail() {
      const modal = document.getElementById('poolDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== ä¿¡å·æ ‡ç­¾é¡µåˆ‡æ¢ ====================
    let currentSignalTab = 'anomaly';

    function switchSignalTab(tab) {
      currentSignalTab = tab;

      // æ›´æ–°æ ‡ç­¾é¡µæŒ‰é’®æ ·å¼
      const tabAnomaly = document.getElementById('tabAnomaly');
      const tabTrade = document.getElementById('tabTrade');
      const anomalyContent = document.getElementById('anomalyTabContent');
      const tradeContent = document.getElementById('tradeTabContent');

      if (tab === 'anomaly') {
        tabAnomaly.className = 'px-2 py-1 text-xs rounded transition-all bg-green-600 text-white';
        tabTrade.className = 'px-2 py-1 text-xs rounded transition-all text-slate-400 hover:text-white';
        anomalyContent.classList.remove('hidden');
        tradeContent.classList.add('hidden');
      } else {
        tabTrade.className = 'px-2 py-1 text-xs rounded transition-all bg-emerald-600 text-white';
        tabAnomaly.className = 'px-2 py-1 text-xs rounded transition-all text-slate-400 hover:text-white';
        tradeContent.classList.remove('hidden');
        anomalyContent.classList.add('hidden');
      }
    }

    // ==================== å¸ƒæ—å¸¦æŒ‡æ ‡è®¡ç®— ====================
    // å‚æ•°: Length=20, MA Type=SMA, StdDev=2.0
    function calculateBollingerBands(closes, length = 20, stdDev = 2.0) {
      if (closes.length < length) {
        throw new Error(`æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦${length}æ ¹Kçº¿`);
      }

      const result = [];

      // è®¡ç®—SMAå’Œæ ‡å‡†å·®
      for (let i = length - 1; i < closes.length; i++) {
        // è·å–æœ€è¿‘lengthä¸ªæ”¶ç›˜ä»·
        const window = closes.slice(i - length + 1, i + 1);

        // è®¡ç®—ç®€å•ç§»åŠ¨å¹³å‡(SMA)
        const sum = window.reduce((acc, val) => acc + val, 0);
        const sma = sum / length;

        // è®¡ç®—æ ‡å‡†å·®
        const variance = window.reduce((acc, val) => acc + Math.pow(val - sma, 2), 0) / length;
        const std = Math.sqrt(variance);

        // è®¡ç®—ä¸Šè½¨ã€ä¸­è½¨ã€ä¸‹è½¨
        const upperBand = sma + (std * stdDev);
        const middleBand = sma;
        const lowerBand = sma - (std * stdDev);

        result.push({
          index: i,
          upperBand,
          middleBand,
          lowerBand
        });
      }

      return result;
    }

    // ==================== ä¹°å–ç‚¹åˆ†æ ====================
    async function analyzeTradePoints() {
      const symbol = document.getElementById('tradeSymbolInput').value.trim().toUpperCase();

      if (!symbol) {
        alert('è¯·è¾“å…¥äº¤æ˜“å¯¹ç¬¦å·ï¼Œä¾‹å¦‚: BTCUSDT');
        return;
      }

      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      document.getElementById('tradeLoading').classList.remove('hidden');
      document.getElementById('tradeEmpty').classList.add('hidden');
      document.getElementById('tradeContent').classList.add('hidden');

      try {
        addLog('info', `å¼€å§‹åˆ†æä¹°å–ç‚¹: ${symbol}`);

        // è·å–1å°æ—¶Kçº¿æ•°æ®
        const klineData = await fetchKlineDataForAnalysis(symbol, '1h', 51);

        if (!klineData || klineData.length < 20) {
          throw new Error('Kçº¿æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦20æ ¹');
        }

        // æå–æ”¶ç›˜ä»·
        const closes = klineData.map(k => k.close);

        // è®¡ç®—å¸ƒæ—å¸¦
        const bollingerBands = calculateBollingerBands(closes);

        // è·å–æœ€æ–°çš„å¸ƒæ—å¸¦å€¼
        const latestBollinger = bollingerBands[bollingerBands.length - 1];
        const currentPrice = closes[closes.length - 1];

        // æ›´æ–°UI
        document.getElementById('tradeLoading').classList.add('hidden');
        document.getElementById('tradeContent').classList.remove('hidden');

        // æ›´æ–°å¸ƒæ—å¸¦æ˜¾ç¤º
        document.getElementById('upperBand').textContent = latestBollinger.upperBand.toFixed(2);
        document.getElementById('middleBand').textContent = latestBollinger.middleBand.toFixed(2);
        document.getElementById('lowerBand').textContent = latestBollinger.lowerBand.toFixed(2);

        // æ›´æ–°å½“å‰ä»·æ ¼
        document.getElementById('currentPrice').textContent = currentPrice.toFixed(2);

        // æ›´æ–°ä»·æ ¼ä½ç½®
        const totalRange = latestBollinger.upperBand - latestBollinger.lowerBand;
        const pricePosition = totalRange > 0 ? ((currentPrice - latestBollinger.lowerBand) / totalRange) * 100 : 50;
        document.getElementById('pricePositionBar').style.width = `${pricePosition}%`;
        document.getElementById('pricePositionIndicator').style.left = `calc(${pricePosition}% - 6px)`;

        // ç”Ÿæˆä¹°å–ç‚¹æç¤º
        const signals = generateTradeSignals(currentPrice, latestBollinger);

        // æ›´æ–°ä¹°å–ç‚¹æç¤º
        const signalsHtml = signals.map(signal => `
          <div class="flex items-start gap-2 p-2 bg-slate-800/50 rounded ${signal.type === 'buy' ? 'border-l-2 border-green-500' : signal.type === 'sell' ? 'border-l-2 border-orange-500' : 'border-l-2 border-slate-500'}">
            <span class="text-lg">${signal.icon}</span>
            <div>
              <div class="font-semibold text-sm ${signal.type === 'buy' ? 'text-green-400' : signal.type === 'sell' ? 'text-orange-400' : 'text-slate-400'}">${signal.title}</div>
              <div class="text-xs text-slate-400 mt-1">${signal.description}</div>
            </div>
          </div>
        `).join('');

        document.getElementById('tradeSignals').innerHTML = signalsHtml || '<div class="text-slate-400 text-xs">æš‚æ— æ˜ç¡®ä¿¡å·</div>';

        addLog('success', `${symbol} ä¹°å–ç‚¹åˆ†æå®Œæˆ`);
      } catch (error) {
        addLog('error', 'ä¹°å–ç‚¹åˆ†æå¤±è´¥', error.message);
        document.getElementById('tradeLoading').classList.add('hidden');
        document.getElementById('tradeEmpty').classList.remove('hidden');
        document.getElementById('tradeEmpty').textContent = `åˆ†æå¤±è´¥: ${error.message}`;
      }
    }

    // ç”Ÿæˆä¹°å–ç‚¹æç¤º
    function generateTradeSignals(currentPrice, bollingerBands) {
      const signals = [];
      const { upperBand, middleBand, lowerBand } = bollingerBands;

      // è®¡ç®—ä»·æ ¼ä½ç½®ç™¾åˆ†æ¯”
      const totalRange = upperBand - lowerBand;
      const pricePosition = totalRange > 0 ? ((currentPrice - lowerBand) / totalRange) * 100 : 50;

      // ä¹°å…¥ä¿¡å·
      if (currentPrice <= lowerBand) {
        signals.push({
          type: 'buy',
          icon: 'ğŸŸ¢',
          title: 'å¼ºçƒˆä¹°å…¥ä¿¡å·',
          description: 'ä»·æ ¼è§¦åŠå¸ƒæ—å¸¦ä¸‹è½¨ï¼Œå¯èƒ½åå¼¹ã€‚å»ºè®®å…³æ³¨ã€‚'
        });
      } else if (pricePosition < 20) {
        signals.push({
          type: 'buy',
          icon: 'ğŸ”µ',
          title: 'ä¹°å…¥æœºä¼š',
          description: 'ä»·æ ¼æ¥è¿‘ä¸‹è½¨ï¼Œå¤„äºè¶…å–åŒºåŸŸï¼Œå¯èƒ½å­˜åœ¨åå¼¹æœºä¼šã€‚'
        });
      } else if (pricePosition < 40) {
        signals.push({
          type: 'neutral',
          icon: 'âšª',
          title: 'è§‚æœ›',
          description: 'ä»·æ ¼åœ¨å¸ƒæ—å¸¦ä¸‹æ–¹åŒºåŸŸï¼Œç­‰å¾…ä¼ç¨³ä¿¡å·ã€‚'
        });
      }

      // å–å‡ºä¿¡å·
      if (currentPrice >= upperBand) {
        signals.push({
          type: 'sell',
          icon: 'ğŸ”´',
          title: 'å¼ºçƒˆå–å‡ºä¿¡å·',
          description: 'ä»·æ ¼è§¦åŠå¸ƒæ—å¸¦ä¸Šè½¨ï¼Œå¯èƒ½å›è°ƒã€‚å»ºè®®å‡ä»“ã€‚'
        });
      } else if (pricePosition > 80) {
        signals.push({
          type: 'sell',
          icon: 'ğŸŸ ',
          title: 'å–å‡ºæœºä¼š',
          description: 'ä»·æ ¼æ¥è¿‘ä¸Šè½¨ï¼Œå¤„äºè¶…ä¹°åŒºåŸŸï¼Œå¯èƒ½å­˜åœ¨å›è°ƒé£é™©ã€‚'
        });
      } else if (pricePosition > 60) {
        signals.push({
          type: 'neutral',
          icon: 'âšª',
          title: 'è§‚æœ›',
          description: 'ä»·æ ¼åœ¨å¸ƒæ—å¸¦ä¸Šæ–¹åŒºåŸŸï¼Œæ³¨æ„å›è°ƒé£é™©ã€‚'
        });
      }

      // ä¸­æ€§åŒºåŸŸ
      if (pricePosition >= 40 && pricePosition <= 60) {
        signals.push({
          type: 'neutral',
          icon: 'âšª',
          title: 'ä¸­æ€§åŒºåŸŸ',
          description: 'ä»·æ ¼åœ¨ä¸­è½¨é™„è¿‘éœ‡è¡ï¼Œç­‰å¾…çªç ´ä¿¡å·ã€‚'
        });
      }

      // è¶‹åŠ¿æç¤º
      if (currentPrice > middleBand && pricePosition > 60) {
        signals.push({
          type: 'sell',
          icon: 'ğŸ“ˆ',
          title: 'ä¸Šå‡è¶‹åŠ¿',
          description: 'ä»·æ ¼åœ¨ä¸­è½¨ä¸Šæ–¹ä¸”æ¥è¿‘ä¸Šè½¨ï¼Œæ³¨æ„è·åˆ©äº†ç»“ã€‚'
        });
      } else if (currentPrice < middleBand && pricePosition < 40) {
        signals.push({
          type: 'buy',
          icon: 'ğŸ“‰',
          title: 'ä¸‹é™è¶‹åŠ¿',
          description: 'ä»·æ ¼åœ¨ä¸­è½¨ä¸‹æ–¹ä¸”æ¥è¿‘ä¸‹è½¨ï¼Œå¯èƒ½è§¦åº•åå¼¹ã€‚'
        });
      }

      return signals;
    }

    // è·å–Kçº¿æ•°æ®ï¼ˆç”¨äºä¹°å–ç‚¹åˆ†æï¼‰
    async function fetchKlineDataForAnalysis(symbol, interval, limit) {
      const endpoints = {
        binance: `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
        okx: `https://www.okx.com/api/v5/market/candles?instId=${symbol}&bar=${interval}&limit=${limit}`,
        bybit: `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${limit}`
      };

      // ä¼˜å…ˆä½¿ç”¨å½“å‰APIæä¾›å•†
      let endpoint = endpoints[currentApiProvider];

      try {
        const response = await fetchWithRetry(endpoint, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false);

        if (!response.ok) {
          throw new Error(`APIè¿”å›é”™è¯¯: ${response.status}`);
        }

        const data = await response.json();

        // æ ¹æ®ä¸åŒAPIæ ¼å¼è§£æKçº¿æ•°æ®
        let klines = [];

        if (currentApiProvider === 'binance') {
          klines = data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
        } else if (currentApiProvider === 'okx') {
          if (data.data && data.data.length > 0) {
            klines = data.data.map(k => ({
              time: k[0],
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }
        } else if (currentApiProvider === 'bybit') {
          if (data.result && data.result.list && data.result.list.length > 0) {
            klines = data.result.list.reverse().map(k => ({
              time: k[0],
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }
        }

        return klines;
      } catch (error) {
        addLog('error', `Kçº¿æ•°æ®è·å–å¤±è´¥ (${currentApiProvider})`, error.message);

        // å°è¯•ä½¿ç”¨å¤‡ç”¨API
        for (const provider of ['binance', 'okx']) {
          if (provider !== currentApiProvider) {
            try {
              addLog('info', `å°è¯•ä½¿ç”¨${provider}è·å–Kçº¿æ•°æ®...`);
              const response = await fetchWithRetry(endpoints[provider], {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
              }, 2, false);

              if (response.ok) {
                const data = await response.json();
                let klines = [];

                if (provider === 'binance') {
                  klines = data.map(k => ({
                    time: k[0],
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                  }));
                } else if (provider === 'okx') {
                  if (data.data && data.data.length > 0) {
                    klines = data.data.map(k => ({
                      time: k[0],
                      open: parseFloat(k[1]),
                      high: parseFloat(k[2]),
                      low: parseFloat(k[3]),
                      close: parseFloat(k[4]),
                      volume: parseFloat(k[5])
                    }));
                  }
                }

                if (klines.length > 0) {
                  addLog('success', `æˆåŠŸä½¿ç”¨${provider}è·å–Kçº¿æ•°æ®`);
                  return klines;
                }
              }
            } catch (e) {
              continue;
            }
          }
        }

        throw error;
      }
    }

    // ==================== æ—¥å¿—ç³»ç»Ÿ ====================
    let logEntries = [];
    let logsExpanded = false;
    let logFilter = 'all'; // å½“å‰æ—¥å¿—ç­›é€‰ç±»å‹: 'all', 'normal', 'error', 'warning'

    function filterLogs(filterType) {
      logFilter = filterType;
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      const buttons = {
        all: document.getElementById('filterAll'),
        normal: document.getElementById('filterNormal'),
        error: document.getElementById('filterError'),
        warning: document.getElementById('filterWarning')
      };
      
      // é‡ç½®æ‰€æœ‰æŒ‰é’®æ ·å¼
      Object.keys(buttons).forEach(key => {
        const btn = buttons[key];
        if (btn) {
          btn.className = 'px-2 py-1 text-xs text-slate-300 hover:bg-slate-600 rounded transition-all';
        }
      });
      
      // è®¾ç½®å½“å‰æ¿€æ´»æŒ‰é’®æ ·å¼
      const activeBtn = buttons[filterType];
      if (activeBtn) {
        const activeClass = {
          all: 'bg-emerald-600 text-white',
          normal: 'bg-green-600 text-white',
          error: 'bg-orange-600 text-white',
          warning: 'bg-yellow-600 text-white'
        };
        activeBtn.className = `px-2 py-1 text-xs ${activeClass[filterType]} rounded transition-all`;
      }
      
      // é‡æ–°æ¸²æŸ“æ—¥å¿—
      updateLogView();
    }

    function addLog(type, message, details = null) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = {
        timestamp,
        type,
        message,
        details
      };

      logEntries.push(logEntry);
      // åªä¿ç•™æœ€è¿‘50æ¡æ—¥å¿—
      if (logEntries.length > 50) {
        logEntries = logEntries.slice(-50);
      }

      updateLogView();
      saveLogs();
    }

    function updateLogView() {
      const container = document.getElementById('logContainer');
      if (!container) return;

      // æ ¹æ®ç­›é€‰ç±»å‹è¿‡æ»¤æ—¥å¿—
      let filteredEntries = logEntries;
      if (logFilter !== 'all') {
        const typeMap = {
          normal: ['info', 'success', 'api'],  // æ­£å¸¸æ—¥å¿—ç±»å‹
          error: ['error'],  // æŠ¥é”™æ—¥å¿—ç±»å‹
          warning: ['warning']  // é”™è¯¯æç¤ºæ—¥å¿—ç±»å‹
        };
        const allowedTypes = typeMap[logFilter] || [];
        filteredEntries = logEntries.filter(entry => allowedTypes.includes(entry.type));
      }

      const logHTML = filteredEntries.map(entry => {
        const typeStyles = {
          info: 'text-emerald-400',
          success: 'text-green-400',
          warning: 'text-yellow-400',
          error: 'text-orange-400',
          api: 'text-slate-400'
        };

        const typeIcons = {
          info: 'â„¹ï¸',
          success: 'âœ…',
          warning: 'âš ï¸',
          error: 'âŒ',
          api: 'ğŸ“¡'
        };

        const styleClass = typeStyles[entry.type] || 'text-slate-400';
        const icon = typeIcons[entry.type] || 'ğŸ“Œ';

        let detailHTML = '';
        if (entry.details) {
          detailHTML = `<div class="text-slate-500 mt-0.5 pl-4 border-l border-slate-700">${entry.details}</div>`;
        }

        return `
          <div class="mb-1 hover:bg-slate-700/30 px-1 py-0.5 rounded transition-colors">
            <div class="flex items-start gap-2">
              <span class="text-slate-500 shrink-0">[${entry.timestamp}]</span>
              <span class="shrink-0">${icon}</span>
              <span class="${styleClass} flex-1">${entry.message}</span>
            </div>
            ${detailHTML}
          </div>
        `;
      }).join('');

      container.innerHTML = logHTML || '<div class="text-slate-500 text-center py-2">æš‚æ— æ—¥å¿—</div>';

      // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
      container.scrollTop = container.scrollHeight;
    }

    function clearLogs() {
      logEntries = [];
      updateLogView();
      addLog('info', 'æ—¥å¿—å·²æ¸…ç©º');
    }

    function toggleLogs() {
      logsExpanded = !logsExpanded;
      const container = document.getElementById('logContainer');
      const btn = document.getElementById('logToggleBtn');

      if (logsExpanded) {
        container.style.display = 'block';
        btn.textContent = 'æ”¶èµ·';
      } else {
        container.style.display = 'none';
        btn.textContent = 'å±•å¼€';
      }
    }

    // ==================== çŠ¶æ€ç®¡ç† ====================
    let binancePrices = [];
    let anomalySignals = [];
    let news = [];
    let hotNews = [];
    let kolOpinions = [];
    let currentTab = 'latest';
    let currentApiProvider = 'bybit'; // é»˜è®¤ä½¿ç”¨Bybit API

    let lastNewsCleanTime = Date.now();
    const NEWS_CLEAN_INTERVAL = 3600000; // 1å°æ—¶æ¸…ç†ä¸€æ¬¡
    const NEWS_CLEAN_COUNT = 12; // æ¯æ¬¡æ¸…ç†12æ¡

    // æ•°æ®æŒä¹…åŒ–é…ç½®
    const DATA_EXPIRE_TIME = 86400000; // 24å°æ—¶è¿‡æœŸ
    const STORAGE_KEYS = {
      anomalySignals: 'anomaly_signals_data',
      news: 'news_data',
      hotNews: 'hot_news_data',
      kolOpinions: 'kol_opinions_data',
      logEntries: 'log_entries_data',
      tickerData: 'ticker_data_data',
      marketOverview: 'market_overview_data',
      trendingCoins: 'trending_coins_data',
      fearGreed: 'fear_greed_data'
    };

    // ==================== æŒä¹…åŒ–å‡½æ•° ====================

    // ä¿å­˜å¼‚åŠ¨ä¿¡å·
    function saveAnomalySignals() {
      try {
        const data = {
          signals: anomalySignals,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.anomalySignals, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜å¼‚åŠ¨ä¿¡å·å¤±è´¥:', error);
      }
    }

    // åŠ è½½å¼‚åŠ¨ä¿¡å·
    function loadAnomalySignals() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.anomalySignals);
        if (saved) {
          const data = JSON.parse(saved);
          // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            anomalySignals = data.signals || [];
            addLog('info', `å·²åŠ è½½ ${anomalySignals.length} æ¡å†å²å¼‚åŠ¨ä¿¡å·`);
          } else {
            localStorage.removeItem(STORAGE_KEYS.anomalySignals);
          }
        }
      } catch (error) {
        console.error('åŠ è½½å¼‚åŠ¨ä¿¡å·å¤±è´¥:', error);
      }
    }

    // ä¿å­˜æ–°é—»æ•°æ®
    function saveNewsData() {
      try {
        const now = Date.now();
        localStorage.setItem(STORAGE_KEYS.news, JSON.stringify({ data: news, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.hotNews, JSON.stringify({ data: hotNews, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.kolOpinions, JSON.stringify({ data: kolOpinions, timestamp: now }));
      } catch (error) {
        console.error('ä¿å­˜æ–°é—»æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½æ–°é—»æ•°æ®
    function loadNewsData() {
      try {
        const now = Date.now();
        const keys = [
          { key: STORAGE_KEYS.news, varName: 'news' },
          { key: STORAGE_KEYS.hotNews, varName: 'hotNews' },
          { key: STORAGE_KEYS.kolOpinions, varName: 'kolOpinions' }
        ];

        keys.forEach(({ key, varName }) => {
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp < DATA_EXPIRE_TIME) {
              window[varName] = data.data || [];
            } else {
              localStorage.removeItem(key);
            }
          }
        });

        const totalCount = news.length + hotNews.length + kolOpinions.length;
        if (totalCount > 0) {
          addLog('info', `å·²åŠ è½½å†å²æ–°é—»æ•°æ®: æœ€æ–°${news.length}æ¡, çƒ­é—¨${hotNews.length}æ¡, KOL${kolOpinions.length}æ¡`);
        }
      } catch (error) {
        console.error('åŠ è½½æ–°é—»æ•°æ®å¤±è´¥:', error);
      }
    }

    // ä¿å­˜äº¤æ˜“å¯¹æ•°æ®
    function saveTickerData() {
      try {
        const data = {
          tickers: binancePrices,
          apiProvider: currentApiProvider,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.tickerData, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜äº¤æ˜“å¯¹æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½äº¤æ˜“å¯¹æ•°æ®
    function loadTickerData() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.tickerData);
        if (saved) {
          const data = JSON.parse(saved);
          // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            binancePrices = data.tickers || [];
            if (data.apiProvider && data.apiProvider !== currentApiProvider) {
              addLog('info', `å·²åŠ è½½å†å²äº¤æ˜“å¯¹æ•°æ®ï¼ˆæ¥æº: ${data.apiProvider.toUpperCase()}ï¼‰ï¼Œå½“å‰ä½¿ç”¨: ${currentApiProvider.toUpperCase()}`);
            } else {
              addLog('info', `å·²åŠ è½½ ${binancePrices.length} ä¸ªå†å²äº¤æ˜“å¯¹æ•°æ®`);
            }
          } else {
            localStorage.removeItem(STORAGE_KEYS.tickerData);
          }
        }
      } catch (error) {
        console.error('åŠ è½½äº¤æ˜“å¯¹æ•°æ®å¤±è´¥:', error);
      }
    }

    // ä¿å­˜æ—¥å¿—
    function saveLogs() {
      try {
        const data = {
          entries: logEntries,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.logEntries, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜æ—¥å¿—å¤±è´¥:', error);
      }
    }

    // åŠ è½½æ—¥å¿—
    function loadLogs() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.logEntries);
        if (saved) {
          const data = JSON.parse(saved);
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            logEntries = data.entries || [];
            if (logEntries.length > 0) {
              addLog('info', `å·²åŠ è½½ ${logEntries.length} æ¡å†å²æ—¥å¿—`);
            }
          } else {
            localStorage.removeItem(STORAGE_KEYS.logEntries);
          }
        }
      } catch (error) {
        console.error('åŠ è½½æ—¥å¿—å¤±è´¥:', error);
      }
    }

    // æ¸…ç†æ‰€æœ‰è¿‡æœŸæ•°æ®

    // ä¿å­˜ç»¼åˆä¿¡æ¯æ•°æ®
    function saveMarketData(marketOverview, trendingCoins, fearGreed) {
      try {
        const now = Date.now();
        localStorage.setItem(STORAGE_KEYS.marketOverview, JSON.stringify({ data: marketOverview, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.trendingCoins, JSON.stringify({ data: trendingCoins, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.fearGreed, JSON.stringify({ data: fearGreed, timestamp: now }));
      } catch (error) {
        console.error('ä¿å­˜ç»¼åˆä¿¡æ¯æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½ç»¼åˆä¿¡æ¯æ•°æ®
    function loadMarketData() {
      try {
        const now = Date.now();
        const result = {};
        ['marketOverview', 'trendingCoins', 'fearGreed'].forEach(varName => {
          const key = STORAGE_KEYS[varName];
          if (!key) return;
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp < DATA_EXPIRE_TIME) {
              result[varName] = data.data;
            } else {
              localStorage.removeItem(key);
            }
          }
        });
        return result;
      } catch (error) {
        console.error('åŠ è½½ç»¼åˆä¿¡æ¯æ•°æ®å¤±è´¥:', error);
        return {};
      }
    }

    function cleanExpiredData() {
      const now = Date.now();
      Object.values(STORAGE_KEYS).forEach(key => {
        try {
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp >= DATA_EXPIRE_TIME) {
              localStorage.removeItem(key);
            }
          }
        } catch (error) {
          console.error(`æ¸…ç†æ•°æ®å¤±è´¥: ${key}`, error);
        }
      });
    }

    // æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®
    function clearAllHistory() {
      Object.values(STORAGE_KEYS).forEach(key => {
        localStorage.removeItem(key);
      });
      anomalySignals = [];
      news = [];
      hotNews = [];
      kolOpinions = [];
      logEntries = [];
      addLog('info', 'å·²æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®');
      updateAnomalyView();
      updateNewsView();
      updateLogView();
    }

    function cleanupNews() {
      const now = Date.now();
      if (now - lastNewsCleanTime > NEWS_CLEAN_INTERVAL) {
        // æ¸…ç†æœ€æ—§çš„12æ¡æ–°é—»
        if (news.length > NEWS_CLEAN_COUNT) {
          news = news.slice(NEWS_CLEAN_COUNT);
        }
        if (hotNews.length > NEWS_CLEAN_COUNT) {
          hotNews = hotNews.slice(NEWS_CLEAN_COUNT);
        }
        if (kolOpinions.length > NEWS_CLEAN_COUNT) {
          kolOpinions = kolOpinions.slice(NEWS_CLEAN_COUNT);
        }
        lastNewsCleanTime = now;
        addLog('info', 'æ–°é—»æ‰¹é‡æ¸…ç†å®Œæˆï¼Œåˆ é™¤æœ€æ—§12æ¡');
      }
    }

    // å¼‚åŠ¨ä¿¡å·æ’åºçŠ¶æ€
    let anomalySortColumn = 'time';
    let anomalySortDirection = 'desc';

    // å¸ç§ç¬¦å·æ˜ å°„è¡¨ (äº¤æ˜“å¯¹ç¬¦å· -> CoinGecko coin ID)
    const COIN_SYMBOL_MAP = {
      'BTC': 'bitcoin',
      'ETH': 'ethereum',
      'BNB': 'binancecoin',
      'XRP': 'ripple',
      'ADA': 'cardano',
      'DOGE': 'dogecoin',
      'SOL': 'solana',
      'DOT': 'polkadot',
      'MATIC': 'matic-network',
      'SHIB': 'shiba-inu',
      'LTC': 'litecoin',
      'AVAX': 'avalanche-2',
      'TRX': 'tron',
      'LINK': 'chainlink',
      'ATOM': 'cosmos',
      'UNI': 'uniswap',
      'XLM': 'stellar',
      'XMR': 'monero',
      'ETC': 'ethereum-classic',
      'BCH': 'bitcoin-cash',
      'ALGO': 'algorand',
      'VET': 'vechain',
      'FIL': 'filecoin',
      'ICP': 'internet-computer',
      'NEAR': 'near',
      'APE': 'apecoin',
      'APT': 'aptos',
      'ARB': 'arbitrum',
      'OP': 'optimism',
      'PEPE': 'pepe',
      'FLOKI': 'floki',
      'ORDI': 'ordi',
      'SATS': 'sats-100k'
    };

    // ==================== API è°ƒç”¨å‡½æ•° ====================

    // CORSä»£ç†é…ç½®ï¼ˆä½¿ç”¨å…¬å…±ä»£ç†ï¼Œæ— éœ€æœ¬åœ°æœåŠ¡å™¨ï¼‰
    // ç›´æ¥åŒå‡»HTMLæ–‡ä»¶å³å¯ä½¿ç”¨
    const CORS_PROXIES = [
      'https://corsproxy.io/?',                // å…¬å…±ä»£ç†1
      'https://api.allorigins.win/raw?url=',  // å…¬å…±ä»£ç†2
      'https://api.codetabs.com/v1/proxy?quest=',  // å…¬å…±ä»£ç†3
      'https://thingproxy.freeboard.io/fetch/',    // å…¬å…±ä»£ç†4
      'https://cors-anywhere.herokuapp.com/'       // å…¬å…±ä»£ç†5
    ];
    let currentProxyIndex = 0;

    // è·å–ä»£ç†URL
    function getProxiedUrl(url) {
      // å¸å®‰ã€CoinGecko APIéœ€è¦ä»£ç†
      // Bybitã€OKXã€Followin APIæ”¯æŒCORSï¼Œä¸éœ€è¦ä»£ç†
      if (url.includes('binance.com') || url.includes('coingecko.com')) {
        const proxy = CORS_PROXIES[currentProxyIndex % CORS_PROXIES.length];
        // å…¬å…±ä»£ç†éœ€è¦URLç¼–ç 
        return proxy + encodeURIComponent(url);
      }
      // å…¶ä»–APIä¸éœ€è¦ä»£ç†
      return url;
    }

    // é€šç”¨APIé‡è¯•å‡½æ•°ï¼ˆå¸¦CORSä»£ç†å’Œ429ç‰¹æ®Šå¤„ç†ï¼‰
    async function fetchWithRetry(url, options = {}, maxRetries = 2, useProxy = true) {
      let lastError;
      let actualUrl = useProxy ? getProxiedUrl(url) : url;

      for (let i = 0; i <= maxRetries; i++) {
        try {
          const response = await fetch(actualUrl, options);

          if (response.ok) {
            return response;
          }

          // 429é”™è¯¯ï¼šCoinGeckoé™æµï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿
          if (response.status === 429) {
            const waitTime = Math.min(60000 * Math.pow(2, i), 120000); // æœ€å¤šç­‰å¾…2åˆ†é’Ÿ
            addLog('warning', `APIé™æµï¼ˆ429ï¼‰ï¼Œç­‰å¾… ${waitTime / 1000} ç§’åé‡è¯•...`);

            if (i < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
            continue;
          }

          // å¦‚æœæ˜¯4xxé”™è¯¯ï¼ˆå®¢æˆ·ç«¯é”™è¯¯ï¼‰ï¼Œä¸é‡è¯•ï¼ˆé™¤äº†429ï¼‰
          if (response.status >= 400 && response.status < 500) {
            return response;
          }

          lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);

          // ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
          if (i < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
          }
        } catch (error) {
          lastError = error;

          // å¦‚æœæ˜¯CORSé”™è¯¯ï¼Œå°è¯•ä¸‹ä¸€ä¸ªä»£ç†
          if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
            if (useProxy && currentProxyIndex < CORS_PROXIES.length - 1) {
              currentProxyIndex++;
              actualUrl = getProxiedUrl(url);
              addLog('info', `CORSé”™è¯¯ï¼Œåˆ‡æ¢ä»£ç†: ${CORS_PROXIES[currentProxyIndex]}`);
              i--; // ä¸å¢åŠ é‡è¯•æ¬¡æ•°
              continue;
            }
          }

          // ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
          if (i < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
          }
        }
      }

      throw lastError;
    }

    // é€šè¿‡CoinGeckoæœç´¢APIæŸ¥æ‰¾å¸ç§ID
    async function searchCoinGeckoId(symbol) {
      const coinSymbol = symbol.replace('USDT', '').toUpperCase();

      try {
        addLog('api', `æ­£åœ¨é€šè¿‡CoinGeckoæœç´¢APIæŸ¥æ‰¾ ${coinSymbol}...`);

        const response = await fetchWithRetry(
          `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(coinSymbol)}`,
          { method: 'GET' },
          3, // å¢åŠ é‡è¯•æ¬¡æ•°
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          return null;
        }

        const data = await response.json();

        if (data.coins && data.coins.length > 0) {
          // æŸ¥æ‰¾æœ€åŒ¹é…çš„ç»“æœï¼ˆä¼˜å…ˆç¬¦å·å®Œå…¨åŒ¹é…ï¼‰
          const bestMatch = data.coins.find(coin =>
            coin.symbol.toUpperCase() === coinSymbol
          ) || data.coins[0];

          addLog('success', `CoinGeckoæœç´¢æ‰¾åˆ° ${coinSymbol} -> ${bestMatch.id}`);

          // ç¼“å­˜ç»“æœ
          coinIdCache.set(symbol, bestMatch.id);

          return bestMatch.id;
        }

        return null;
      } catch (error) {
        addLog('error', `CoinGeckoæœç´¢å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– CoinGecko å¸ç§ä¿¡æ¯
    async function fetchCoinGeckoInfo(symbol) {
      const coinSymbol = symbol.replace('USDT', '').toUpperCase();

      try {
        addLog('api', `æ­£åœ¨è¿æ¥CoinGecko APIè·å– ${symbol} å¸ç§ä¿¡æ¯...`);

        // 1. é¦–å…ˆå°è¯•ä½¿ç”¨æ˜ å°„è¡¨
        let coinId = COIN_SYMBOL_MAP[coinSymbol];

        // 2. å¦‚æœæ˜ å°„è¡¨æ²¡æœ‰ï¼Œå°è¯•æœç´¢ç¼“å­˜
        if (!coinId && coinIdCache.has(symbol)) {
          coinId = coinIdCache.get(symbol);
        }

        // 3. å¦‚æœç¼“å­˜ä¹Ÿæ²¡æœ‰ï¼Œå°è¯•æœç´¢API
        if (!coinId) {
          coinId = await searchCoinGeckoId(symbol);
          if (!coinId) {
            addLog('warning', `CoinGeckoæœªæ‰¾åˆ°å¸ç§: ${coinSymbol}`);
            return null;
          }
        }

        // 4. ä½¿ç”¨æ‰¾åˆ°çš„IDè·å–å¸ç§è¯¦æƒ…ï¼ˆlocalization=falseä»¥è·å–åŸå§‹å¤šè¯­è¨€æ•°æ®ï¼‰
        const response = await fetchWithRetry(
          `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&community_data=false&developer_data=false`,
          { method: 'GET' },
          3, // å¢åŠ é‡è¯•æ¬¡æ•°ä»¥åº”å¯¹é™æµ
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          if (response.status === 404) {
            addLog('warning', `CoinGeckoæœªæ‰¾åˆ°å¸ç§ID: ${coinId}`);
          } else if (response.status === 429) {
            addLog('warning', `CoinGecko APIé™æµï¼ˆ429ï¼‰ï¼Œè¯·ç¨åé‡è¯•`);
          } else {
            addLog('error', `CoinGecko APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
          }
          return null;
        }

        const data = await response.json();
        addLog('success', `CoinGeckoè·å– ${symbol} å¸ç§ä¿¡æ¯æˆåŠŸ`);

        return {
          id: data.id,
          symbol: data.symbol,
          name: data.name,
          image: data.image,
          description: data.description || {},
          marketCapRank: data.market_cap_rank || 'N/A',
          categories: data.categories || [],
          currentPrice: {
            usd: data.market_data?.current_price?.usd || 0
          },
          marketCap: {
            usd: data.market_data?.market_cap?.usd || 0
          },
          totalVolume: {
            usd: data.market_data?.total_volume?.usd || 0
          },
          circulatingSupply: data.market_data?.circulating_supply || 0,
          totalSupply: data.market_data?.total_supply || 0,
          maxSupply: data.market_data?.max_supply || 0,
          fullyDilutedValuation: data.market_data?.fully_diluted_valuation?.usd || 0,
          priceChange24h: data.market_data?.price_change_percentage_24h || 0,
          priceChange1h: data.market_data?.price_change_percentage_1h_in_currency?.usd || 0,
          priceChange7d: data.market_data?.price_change_percentage_7d || 0,
          priceChange30d: data.market_data?.price_change_percentage_30d || 0,
          ath: {
            usd: data.market_data?.ath?.usd || 0,
            changePercentage: data.market_data?.ath_change_percentage?.usd || 0,
            date: data.market_data?.ath_date?.usd || ''
          },
          atl: {
            usd: data.market_data?.atl?.usd || 0,
            changePercentage: data.market_data?.atl_change_percentage?.usd || 0,
            date: data.market_data?.atl_date?.usd || ''
          }
        };
      } catch (error) {
        // åŒºåˆ†ç½‘ç»œé”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          addLog('warning', `CoinGeckoç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå¯èƒ½æ˜¯é™æµæˆ–ç½‘ç»œé—®é¢˜`, error.message);
        } else {
          addLog('error', `CoinGeckoè·å– ${symbol} å¸ç§ä¿¡æ¯å¤±è´¥`, error.message);
        }
        return null;
      }
    }

    // è·å–å¸å®‰ç°è´§äº¤æ˜“é‡æ•°æ®ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰
    async function fetchBinanceSpotVolume(symbol) {
      try {
        addLog('api', `å°è¯•è¿æ¥å¸å®‰ç°è´§APIè·å– ${symbol} äº¤æ˜“é‡æ•°æ®...`);

        // å…ˆéªŒè¯äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨
        const verifyResponse = await fetchWithRetry(
          `https://api.binance.com/api/v3/exchangeInfo?symbol=${symbol}`,
          { method: 'GET' },
          1, // éªŒè¯è¯·æ±‚åªéœ€1æ¬¡é‡è¯•
          true // ä½¿ç”¨ä»£ç†
        );

        if (verifyResponse.status === 400) {
          addLog('warning', `å¸å®‰ç°è´§ä¸å­˜åœ¨äº¤æ˜“å¯¹: ${symbol}ï¼Œè·³è¿‡è·å–äº¤æ˜“é‡æ•°æ®`);
          return null;
        }

        if (!verifyResponse.ok) {
          addLog('warning', `å¸å®‰ç°è´§éªŒè¯å¤±è´¥: ${verifyResponse.status}ï¼Œä»å°è¯•è·å–äº¤æ˜“é‡`);
        }

        const response = await fetchWithRetry(
          `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1m&limit=300`,
          { method: 'GET' },
          2,
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          if (response.status === 400) {
            addLog('warning', `å¸å®‰ç°è´§ä¸å­˜åœ¨äº¤æ˜“å¯¹: ${symbol}`);
          } else {
            addLog('warning', `å¸å®‰ç°è´§APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
          }
          return null;
        }

        const klines = await response.json();

        // Kçº¿æ•°æ®ç»“æ„ï¼š[æ—¶é—´æˆ³, å¼€ç›˜ä»·, æœ€é«˜ä»·, æœ€ä½ä»·, æ”¶ç›˜ä»·, æˆäº¤é‡, æˆäº¤æ—¶é—´, æˆäº¤ç¬”æ•°, ...]
        // index[7] = æˆäº¤é¢ï¼ˆå•ä½ï¼šUSDTï¼‰
        const volume5m = klines.slice(0, 5).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume15m = klines.slice(0, 15).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume1h = klines.slice(0, 60).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume4h = klines.slice(0, 240).reduce((sum, k) => sum + parseFloat(k[7]), 0);

        addLog('success', `å¸å®‰ç°è´§è·å– ${symbol} äº¤æ˜“é‡æ•°æ®æˆåŠŸ`);

        return {
          '5m': volume5m,
          '15m': volume15m,
          '1h': volume1h,
          '4h': volume4h
        };
      } catch (error) {
        addLog('warning', `å¸å®‰ç°è´§è·å– ${symbol} äº¤æ˜“é‡æ•°æ®å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– Bybit ç°è´§äº¤æ˜“é‡æ•°æ®
    async function fetchBybitVolume(symbol) {
      try {
        addLog('api', `æ­£åœ¨è¿æ¥Bybit APIè·å– ${symbol} äº¤æ˜“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=1&limit=300`,
          { method: 'GET' },
          2,
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          addLog('warning', `Bybit APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`);
          // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
          return await fetchBinanceSpotVolume(symbol);
        }

        const data = await response.json();

        if (data.retCode !== 0) {
          addLog('warning', `Bybit APIé”™è¯¯: ${data.retMsg}ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`);
          // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
          return await fetchBinanceSpotVolume(symbol);
        }

        const klines = data.result.list;

        // Kçº¿æ•°æ®ç»“æ„ï¼š[æ—¶é—´æˆ³, å¼€ç›˜ä»·, æœ€é«˜ä»·, æœ€ä½ä»·, æ”¶ç›˜ä»·, æˆäº¤é‡, æˆäº¤é¢, æˆäº¤ç¬”æ•°]
        // index[6] = æˆäº¤é¢ï¼ˆå•ä½ï¼šUSDTï¼‰
        const volume5m = klines.slice(0, 5).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume15m = klines.slice(0, 15).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume1h = klines.slice(0, 60).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume4h = klines.slice(0, 240).reduce((sum, k) => sum + parseFloat(k[6]), 0);

        addLog('success', `Bybitè·å– ${symbol} äº¤æ˜“é‡æ•°æ®æˆåŠŸ`);

        return {
          '5m': volume5m,
          '15m': volume15m,
          '1h': volume1h,
          '4h': volume4h
        };
      } catch (error) {
        addLog('warning', `Bybitè·å– ${symbol} äº¤æ˜“é‡æ•°æ®å¤±è´¥ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`, error.message);
        // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
        return await fetchBinanceSpotVolume(symbol);
      }
    }

    // åˆ‡æ¢APIæä¾›å•†
    function switchApiProvider() {
      const selector = document.getElementById('apiSelector');
      if (!selector) return;

      currentApiProvider = selector.value;
      addLog('info', `åˆ‡æ¢APIæä¾›å•†ä¸º: ${currentApiProvider.toUpperCase()}`);

      // æ¸…ç©ºä»·æ ¼ç¼“å­˜æ•°æ®ï¼ˆä¿ç•™å¼‚åŠ¨ä¿¡å·ï¼Œé¿å…ä¸¢å¤±å·²ç›‘æ§çš„äº¤æ˜“å¯¹ï¼‰
      binancePrices = [];
      localStorage.removeItem(STORAGE_KEYS.tickerData); // æ¸…ç©ºäº¤æ˜“å¯¹æ•°æ®ç¼“å­˜

      // ç«‹å³åˆ·æ–°æ•°æ®
      updateAnomalyView();
      addLog('info', 'å·²ä¿ç•™å¼‚åŠ¨ä¿¡å·å†å²ï¼Œæ­£åœ¨é‡æ–°è·å–è¡Œæƒ…æ•°æ®...');

      // è§¦å‘æ•°æ®åˆ·æ–°
      refreshAll();
    }

    // è·å–æè´ªæŒ‡æ•°ï¼ˆä½¿ç”¨Alternative.me + å¤‡ç”¨æ–¹æ¡ˆï¼‰
    async function fetchFearGreedIndex() {
      // å°è¯•å¤šä¸ªAPIæº
      const apiSources = [
        {
          name: 'Alternative.me (ä¸»)',
          url: `${FEAR_GREED_API_URL}?limit=1`,
          useProxy: false
        },
        {
          name: 'Alternative.me (ä»£ç†)',
          url: `${FEAR_GREED_API_URL}?limit=1`,
          useProxy: true
        }
      ];

      for (const source of apiSources) {
        try {
          addLog('api', `æ­£åœ¨å°è¯•${source.name}è·å–æè´ªæŒ‡æ•°...`);
          
          const response = await fetchWithRetry(
            source.url,
            { method: 'GET', headers: { 'Content-Type': 'application/json' } },
            2,
            source.useProxy
          );
          
          if (!response.ok) {
            addLog('warning', `${source.name}è¿æ¥å¤±è´¥: ${response.status}`);
            continue;
          }
          
          const json = await response.json();
          
          if (!json || !json.data || json.data.length === 0) {
            addLog('warning', `${source.name}è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸`);
            continue;
          }
          
          const fgData = json.data[0];
          addLog('success', `æè´ªæŒ‡æ•°è·å–æˆåŠŸ (${source.name})`);
          
          return {
            value: fgData.value,
            classification: fgData.value_classification,
            timestamp: fgData.timestamp
          };
        } catch (error) {
          addLog('warning', `${source.name}è·å–å¤±è´¥: ${error.message}`);
          continue;
        }
      }
      
      // æ‰€æœ‰APIéƒ½å¤±è´¥äº†ï¼Œè¿”å›é»˜è®¤å€¼
      addLog('warning', 'æ‰€æœ‰æè´ªæŒ‡æ•°APIå‡å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
      return {
        value: 50,
        classification: 'Neutral',
        timestamp: Date.now()
      };
    }

    // ==================== CoinGecko API è°ƒç”¨å‡½æ•° ====================

    // è·å–å¸‚åœºæ¦‚è§ˆæ•°æ®ï¼ˆBTC/ETHä»·æ ¼ã€å…¨çƒå¸‚å€¼ç­‰ï¼‰- ä½¿ç”¨æ··åˆAPI
    async function fetchMarketOverview() {
      try {
        addLog('api', 'æ­£åœ¨è·å–å¸‚åœºæ¦‚è§ˆæ•°æ®ï¼ˆæ··åˆAPIï¼‰...');
        
        if (!API_CONFIG.useCryptoCompare && !API_CONFIG.useAlternative) {
          addLog('error', 'æœªå¯ç”¨ä»»ä½•å¸‚åœºæ¦‚è§ˆAPI');
          return null;
        }
        
        let btcPrice = null;
        let ethPrice = null;
        let globalData = null;
        
        // ä½¿ç”¨CryptoCompareè·å–æ•°æ®ï¼ˆå†…éƒ¨å·²åŒ…å«CoinGeckoå¤‡ç”¨æ–¹æ¡ˆï¼‰
        if (API_CONFIG.useCryptoCompare) {
          try {
            const results = await Promise.all([
              fetchCryptoComparePrices(),
              fetchCryptoCompareETHPrice(),
              fetchCryptoCompareGlobalData()  // è¿™ä¸ªå‡½æ•°å†…éƒ¨å·²åŒ…å«å¤‡ç”¨æ–¹æ¡ˆ
            ]);
            btcPrice = results[0];
            ethPrice = results[1];
            globalData = results[2];
          } catch (error) {
            addLog('error', 'CryptoCompareéƒ¨åˆ†æ•°æ®è·å–å¤±è´¥: ' + error.message);
          }
        }
        
        if (!globalData) {
          addLog('error', 'æ‰€æœ‰å¸‚åœºæ¦‚è§ˆæ•°æ®æºå‡å¤±è´¥ï¼ˆåŒ…æ‹¬å¤‡ç”¨æ–¹æ¡ˆï¼‰');
          return null;
        }
        
        addLog('success', 'å¸‚åœºæ¦‚è§ˆæ•°æ®è·å–æˆåŠŸ');
        
        // æ„å»ºè¿”å›æ•°æ®ï¼ˆå…¼å®¹åŸæœ‰æ ¼å¼ï¼‰
        return {
          bitcoin: {
            current_price: btcPrice?.btc?.USD || 0,
            price_change_percentage_24h: 0
          },
          ethereum: {
            current_price: ethPrice?.USD || 0,
            price_change_percentage_24h: 0
          },
          global: {
            total_market_cap: { usd: globalData.TOTAL_VALUE?.USD || 0 },
            market_cap_change_percentage_24h_usd: 0,
            total_volume: { usd: globalData.TOTAL_VOLUME?.USD || 0 },
            active_cryptocurrencies: globalData.COIN_COUNT || 0,
            market_cap_percentage: {
              btc: globalData.BTC_DOMINANCE || 0,
              eth: globalData.ETH_DOMINANCE || 0
            }
          }
        };
      } catch (error) {
        addLog('error', 'è·å–å¸‚åœºæ¦‚è§ˆå¤±è´¥: ' + error.message);
        return null;
      }
    }

    // è·å–çƒ­é—¨æœç´¢ä»£å¸ - ä½¿ç”¨Coinlore
    async function fetchTrendingCoins() {
      if (API_CONFIG.useCoinlore) {
        return await fetchCoinloreTrending();
      }
      
      // å¦‚æœCoinloreæœªå¯ç”¨ï¼Œä½¿ç”¨CoinGeckoå¤‡ç”¨
      try {
        const response = await fetchWithRetry('https://api.coingecko.com/api/v3/search/trending', {}, 1, true);

        if (!response.ok) {
          addLog('error', 'CoinGeckoçƒ­é—¨æœç´¢è·å–å¤±è´¥');
          return [];
        }

        const data = await response.json();
        addLog('success', `CoinGeckoçƒ­é—¨æœç´¢è·å–æˆåŠŸï¼Œå…±${data.coins.length}ä¸ª`);
        return data.coins.slice(0, 7);
      } catch (error) {
        addLog('error', 'CoinGeckoçƒ­é—¨æœç´¢è·å–å¤±è´¥', error.message);
        return [];
      }
    }

    // è·å–ä»£å¸åˆ†ç±»åˆ—è¡¨
    async function fetchCoinCategories() {
      try {
        const response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/categories', {}, 2, true);

        if (!response.ok) {
          addLog('error', 'CoinGeckoåˆ†ç±»åˆ—è¡¨è·å–å¤±è´¥');
          return [];
        }

        const data = await response.json();
        return data;
      } catch (error) {
        addLog('error', 'CoinGeckoåˆ†ç±»åˆ—è¡¨è·å–å¤±è´¥', error.message);
        return [];
      }
    }

    // ==================== æ··åˆAPIå‡½æ•°ï¼ˆ2026å¹´æ–¹æ¡ˆï¼‰====================

    // è·å–BTC/ETHä»·æ ¼ï¼ˆä½¿ç”¨CryptoCompareï¼‰
    async function fetchCryptoComparePrices() {
      try {
        let url = `${CRYPTOCOMPARE_API_URL}/price?fsym=BTC&tsyms=USD,ETH`;
        // æ·»åŠ API Keyï¼ˆå¦‚æœæœ‰ï¼‰
        if (CRYPTOCOMPARE_API_KEY) {
          url += `&api_key=${CRYPTOCOMPARE_API_KEY}`;
        }
        const response = await fetchWithRetry(url, {}, 2, true);
        if (!response.ok) return null;
        
        const btcData = await response.json();
        addLog('success', 'CryptoCompareè·å–BTCä»·æ ¼æˆåŠŸ');
        
        return {
          btc: btcData,
          eth: null
        };
      } catch (error) {
        addLog('error', 'CryptoCompareè·å–ä»·æ ¼å¤±è´¥', error.message);
        return null;
      }
    }
    
    // è·å–ETHä»·æ ¼ï¼ˆä½¿ç”¨CryptoCompareï¼‰
    async function fetchCryptoCompareETHPrice() {
      try {
        let url = `${CRYPTOCOMPARE_API_URL}/price?fsym=ETH&tsyms=USD`;
        // æ·»åŠ API Keyï¼ˆå¦‚æœæœ‰ï¼‰
        if (CRYPTOCOMPARE_API_KEY) {
          url += `&api_key=${CRYPTOCOMPARE_API_KEY}`;
        }
        const response = await fetchWithRetry(url, {}, 2, true);
        if (!response.ok) return null;
        
        return await response.json();
      } catch (error) {
        return null;
      }
    }
    
    // è·å–å…¨çƒå¸‚åœºæ•°æ®ï¼ˆä½¿ç”¨CryptoCompareï¼‰
    async function fetchCryptoCompareGlobalData() {
      try {
        addLog('api', 'æ­£åœ¨è·å–CryptoCompareå…¨çƒæ•°æ®...');
        let url = `${CRYPTOCOMPARE_API_URL}/global/mktcap?tsym=USD`;
        // æ·»åŠ API Keyï¼ˆå¦‚æœæœ‰ï¼‰
        if (CRYPTOCOMPARE_API_KEY) {
          url += `&api_key=${CRYPTOCOMPARE_API_KEY}`;
        }
        const response = await fetchWithRetry(url, {}, 2, false);  // CryptoCompareæ”¯æŒCORS
        if (!response.ok) {
          addLog('warning', `CryptoCompareå…¨çƒæ•°æ®APIè¿”å›é”™è¯¯ (${response.status})ï¼Œå°è¯•CoinGeckoå¤‡ç”¨`);
          return await fetchCoinGeckoGlobalData();
        }
        
        const json = await response.json();
        
        // CryptoCompare /global/mktcap ç«¯ç‚¹å¯èƒ½è¿”å›å¤šç§æ ¼å¼
        // å°è¯•å¤šç§å¯èƒ½çš„å­—æ®µå
        const data = json.DATA || json.data || json;
        
        // æ‰“å°è¿”å›çš„æ•°æ®ç»“æ„ä»¥ä¾¿è°ƒè¯•
        if (!data) {
          addLog('warning', 'CryptoCompareè¿”å›çš„æ•°æ®ä¸ºç©ºï¼Œå°è¯•CoinGeckoå¤‡ç”¨');
          return await fetchCoinGeckoGlobalData();
        }
        
        // å°è¯•å¤šç§å¯èƒ½çš„å­—æ®µåæ˜ å°„
        const mktCap = data.MKT_CAP || data.mkt_cap || data.total_mkt_cap || data.total_mkt_cap_usd || 0;
        const totalVol = data.TOTAL_VOL || data.total_vol || data.total_volume_24h_usd || data.total_volume || 0;
        const coinCount = data.COIN_COUNT || data.coin_count || data.active_cryptocurrencies || data.ActiveCryptocurrencies || 0;
        const btcDom = data.BTC_DOMINANCE || data.btc_dominance || data.BtcDominance || 0;
        const ethDom = data.ETH_DOMINANCE || data.eth_dominance || data.EthDominance || 0;
        
        // å¦‚æœæ‰€æœ‰å…³é”®å­—æ®µéƒ½ä¸º0ï¼Œè¯´æ˜æ•°æ®æ ¼å¼ä¸æ­£ç¡®
        if (mktCap === 0 && totalVol === 0) {
          addLog('warning', 'CryptoCompareå…¨çƒæ•°æ®æ ¼å¼å¼‚å¸¸ï¼ˆæ‰€æœ‰å­—æ®µä¸º0ï¼‰ï¼Œå°è¯•CoinGeckoå¤‡ç”¨');
          return await fetchCoinGeckoGlobalData();
        }
        
        addLog('success', 'CryptoCompareè·å–å…¨çƒæ•°æ®æˆåŠŸ');
        
        // è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
        return {
          TOTAL_VALUE: { USD: mktCap },
          TOTAL_VOLUME: { USD: totalVol },
          COIN_COUNT: coinCount,
          BTC_DOMINANCE: btcDom,
          ETH_DOMINANCE: ethDom
        };
      } catch (error) {
        addLog('warning', 'CryptoCompareè·å–å…¨çƒæ•°æ®å¤±è´¥ï¼Œå°è¯•CoinGeckoå¤‡ç”¨: ' + error.message);
        return await fetchCoinGeckoGlobalData();
      }
    }

    // ä½¿ç”¨CoinGeckoä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆè·å–å…¨çƒæ•°æ®
    async function fetchCoinGeckoGlobalData() {
      try {
        addLog('api', 'æ­£åœ¨è·å–CoinGeckoå…¨çƒæ•°æ®ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰...');
        // å¢åŠ é‡è¯•æ¬¡æ•°åˆ°3æ¬¡ï¼Œç­‰å¾…æ—¶é—´æ›´é•¿
        const response = await fetchWithRetry('https://api.coingecko.com/api/v3/global', {}, 3, true);
        if (!response.ok) {
          addLog('error', `CoinGeckoå…¨çƒæ•°æ®APIä¹Ÿå¤±è´¥ (çŠ¶æ€ç : ${response.status})`);
          return null;
        }
        const json = await response.json();
        const data = json.data;
        
        if (!data) {
          addLog('error', 'CoinGeckoè¿”å›çš„æ•°æ®æ ¼å¼å¼‚å¸¸ï¼šdataå­—æ®µä¸å­˜åœ¨');
          return null;
        }
        
        addLog('success', 'CoinGeckoè·å–å…¨çƒæ•°æ®æˆåŠŸ');
        
        return {
          TOTAL_VALUE: { USD: data.total_market_cap?.usd || 0 },
          TOTAL_VOLUME: { USD: data.total_volume?.usd || 0 },
          COIN_COUNT: data.active_cryptocurrencies || 0,
          BTC_DOMINANCE: data.market_cap_percentage?.btc || 0,
          ETH_DOMINANCE: data.market_cap_percentage?.eth || 0
        };
      } catch (error) {
        addLog('error', 'CoinGeckoè·å–å…¨çƒæ•°æ®å¤±è´¥: ' + error.message);
        return null;
      }
    }
    
    // è·å–çƒ­é—¨ä»£å¸ï¼ˆä½¿ç”¨Coinloreï¼Œå…è´¹æ— é™ï¼‰
    async function fetchCoinloreTrending() {
      try {
        addLog('api', 'æ­£åœ¨è¿æ¥Coinlore APIè·å–çƒ­é—¨ä»£å¸...');
        
        const url = `${COINLORE_API_URL}/tickers/?start=0&limit=20`;
        const response = await fetchWithRetry(url, {}, 2, true);
        
        if (!response.ok) {
          addLog('error', 'Coinlore APIè¿æ¥å¤±è´¥');
          return [];
        }
        
        const json = await response.json();
        
        if (!json || !json.data) {
          addLog('error', 'Coinlore APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸');
          return [];
        }
        
        addLog('success', `Coinloreè·å–çƒ­é—¨ä»£å¸æˆåŠŸï¼Œå…±${json.data.length}ä¸ª`);
        
        return json.data.slice(0, 10).map(coin => ({
          id: coin.id,
          name: coin.name,
          symbol: coin.symbol,
          thumb: coin.icon || null,
          market_cap_rank: coin.rank || null
        }));
      } catch (error) {
        addLog('error', 'Coinloreè·å–çƒ­é—¨ä»£å¸å¤±è´¥', error.message);
        return [];
      }
    }

    // è·å–ä»£å¸è¯¦æƒ…ï¼ˆç”¨äºåˆ†ç±»ï¼‰
    async function fetchCoinDetails(coinId) {
      try {
        const response = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false`, {}, 2, true);

        if (!response.ok) {
          return null;
        }

        const data = await response.json();
        return data;
      } catch (error) {
        return null;
      }
    }

    // å¼‚åŠ¨åˆ†å¸ƒç»Ÿè®¡ï¼ˆæŒ‰åˆ†ç±»åˆ†ç»„ï¼‰
    async function calculateAnomalyDistribution(signals) {
      try {
        const categoryMap = new Map();

        for (const signal of signals) {
          // è·å–ä»£å¸åˆ†ç±»
          let categories = [];
          const coinId = await searchCoinGeckoId(signal.symbol);

          if (coinId) {
            const details = await fetchCoinDetails(coinId);
            if (details && details.categories) {
              categories = details.categories;
            }
          }

          // å¦‚æœæ²¡æœ‰åˆ†ç±»ï¼Œå½’ä¸º"å…¶ä»–"
          if (categories.length === 0) {
            categories = ['å…¶ä»–'];
          }

          // ç»Ÿè®¡æ¯ä¸ªåˆ†ç±»çš„å¼‚åŠ¨æ•°é‡
          categories.forEach(category => {
            const count = categoryMap.get(category) || 0;
            categoryMap.set(category, count + 1);
          });
        }

        // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
        const distribution = Array.from(categoryMap.entries())
          .map(([category, count]) => ({ category, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 5); // å–TOP5

        return distribution;
      } catch (error) {
        console.error('è®¡ç®—å¼‚åŠ¨åˆ†å¸ƒå¤±è´¥:', error);
        return [];
      }
    }

    // åˆ‡æ¢ç»¼åˆä¿¡æ¯æ ‡ç­¾
    function switchMarketTab(tab) {
      // æ›´æ–°æŒ‰é’®æ ·å¼
      ['Market', 'Anomaly', 'Trending', 'Pools'].forEach(name => {
        const btn = document.getElementById(`tab${name}`);
        if (name.toLowerCase() === tab) {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-emerald-500 text-white';
        } else {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-700 text-slate-300 hover:bg-slate-600';
        }
      });

      // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
      ['Market', 'Anomaly', 'Trending', 'Pools'].forEach(name => {
        const content = document.getElementById(`content${name}`);
        if (name.toLowerCase() === tab) {
          content.classList.remove('hidden');
        } else {
          content.classList.add('hidden');
        }
      });

      // å¦‚æœåˆ‡æ¢åˆ°å¼‚åŠ¨åˆ†å¸ƒï¼Œåˆ·æ–°å¼‚åŠ¨ç»Ÿè®¡æ•°æ®
      if (tab === 'anomaly' && anomalySignals.length > 0) {
        updateAnomalyDistribution();
      }

      // å¦‚æœåˆ‡æ¢åˆ°é“¾ä¸Šæ± å­æ ‡ç­¾ï¼ŒåŠ è½½æ± å­æ•°æ®
      if (tab === 'pools') {
        fetchOnchainPools();
      }
    }

    // åˆ·æ–°å¸‚åœºæ•°æ®
    async function refreshMarketData() {
      try {
        // æ›´æ–°æ—¶é—´æˆ³
        const lastUpdateEl = document.getElementById('marketDataLastUpdate');
        if (lastUpdateEl) {
          lastUpdateEl.textContent = `æ›´æ–°: ${new Date().toLocaleTimeString('zh-CN')}`;
        }

        // è·å–å¸‚åœºæ¦‚è§ˆ
        const marketOverview = await fetchMarketOverview();
        addLog('info', `å¸‚åœºæ¦‚è§ˆæ•°æ®: ${marketOverview ? 'è·å–æˆåŠŸ' : 'è·å–å¤±è´¥'}`);
        
        if (marketOverview) {
          addLog('info', `BTCä»·æ ¼: ${marketOverview.bitcoin?.current_price || 0}, ETHä»·æ ¼: ${marketOverview.ethereum?.current_price || 0}`);
          
          // æ›´æ–°BTCä»·æ ¼
          if (marketOverview.bitcoin) {
            const btc = marketOverview.bitcoin;
            const btcChange = btc.price_change_percentage_24h || 0;
            const btcChangeClass = btcChange >= 0 ? 'text-green-400' : 'text-orange-400';
            const btcChangeIcon = btcChange >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';

            const btcPriceEl = document.getElementById('btcPrice');
            if (btcPriceEl) {
              btcPriceEl.innerHTML = `
                $${btc.current_price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                <span class="${btcChangeClass}">${btcChangeIcon} ${Math.abs(btcChange).toFixed(2)}%</span>
              `;
              addLog('success', 'BTCä»·æ ¼å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°btcPriceå…ƒç´ ');
            }
          }

          // æ›´æ–°ETHä»·æ ¼
          if (marketOverview.ethereum) {
            const eth = marketOverview.ethereum;
            const ethChange = eth.price_change_percentage_24h || 0;
            const ethChangeClass = ethChange >= 0 ? 'text-green-400' : 'text-orange-400';
            const ethChangeIcon = ethChange >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';

            const ethPriceEl = document.getElementById('ethPrice');
            if (ethPriceEl) {
              ethPriceEl.innerHTML = `
                $${eth.current_price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                <span class="${ethChangeClass}">${ethChangeIcon} ${Math.abs(ethChange).toFixed(2)}%</span>
              `;
              addLog('success', 'ETHä»·æ ¼å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°ethPriceå…ƒç´ ');
            }
          }

          // æ›´æ–°æ€»å¸‚å€¼
          if (marketOverview.global) {
            const totalMarketCap = marketOverview.global.total_market_cap.usd;
            const marketCapChange = marketOverview.global.market_cap_change_percentage_24h_usd || 0;
            const marketCapClass = marketCapChange >= 0 ? 'text-green-400' : 'text-orange-400';
            const marketCapIcon = marketCapChange >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';

            const totalMarketCapEl = document.getElementById('totalMarketCap');
            if (totalMarketCapEl) {
              totalMarketCapEl.innerHTML = `
                $${(totalMarketCap / 1e12).toFixed(2)}T
                <span class="${marketCapClass}">${marketCapIcon} ${Math.abs(marketCapChange).toFixed(2)}%</span>
              `;
              addLog('success', 'æ€»å¸‚å€¼å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°totalMarketCapå…ƒç´ ');
            }
          }

          // æ›´æ–°BTCå æ¯”
          if (marketOverview.global) {
            const btcDominance = marketOverview.global.market_cap_percentage.btc || 0;
            const btcDominanceEl = document.getElementById('btcDominance');
            if (btcDominanceEl) {
              btcDominanceEl.textContent = `${btcDominance.toFixed(1)}%`;
              addLog('success', 'BTCå æ¯”å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°btcDominanceå…ƒç´ ');
            }
          }
          
          // æ›´æ–°24häº¤æ˜“é‡
          if (marketOverview.global) {
            const totalVolume = marketOverview.global.total_volume.usd;
            const totalVolumeEl = document.getElementById('totalVolume');
            if (totalVolumeEl) {
              totalVolumeEl.textContent = `$${(totalVolume / 1e9).toFixed(2)}B`;
              addLog('success', '24häº¤æ˜“é‡å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°totalVolumeå…ƒç´ ');
            }
          }
          
          // æ›´æ–°æ´»è·ƒå¸ç§
          if (marketOverview.global) {
            const activeCryptos = marketOverview.global.active_cryptocurrencies;
            const activeCryptosEl = document.getElementById('activeCryptos');
            if (activeCryptosEl) {
              activeCryptosEl.textContent = activeCryptos.toLocaleString();
              addLog('success', 'æ´»è·ƒå¸ç§å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°activeCryptoså…ƒç´ ');
            }
          }
          
          // æ›´æ–°ETHå æ¯”
          if (marketOverview.global) {
            const ethDominance = marketOverview.global.market_cap_percentage.eth || 0;
            const ethDominanceEl = document.getElementById('ethDominance');
            if (ethDominanceEl) {
              ethDominanceEl.textContent = `${ethDominance.toFixed(1)}%`;
              addLog('success', 'ETHå æ¯”å·²æ›´æ–°');
            } else {
              addLog('error', 'æ‰¾ä¸åˆ°ethDominanceå…ƒç´ ');
            }
          }
        } else {
          addLog('warning', 'å¸‚åœºæ¦‚è§ˆæ•°æ®ä¸ºç©ºï¼Œè·³è¿‡æ›´æ–°');
        }

        // è·å–æè´ªæŒ‡æ•°
        const fearGreed = await fetchFearGreedIndex();
        if (fearGreed) {
          const fearGreedEl = document.getElementById('fearGreed');
          const fearGreedLabelEl = document.getElementById('fearGreedLabel');
          const fearGreedUpdateEl = document.getElementById('fearGreedUpdate');
          
          if (fearGreedEl) {
            // æ ¹æ®æŒ‡æ•°å€¼è®¾ç½®é¢œè‰²
            let fgClass = 'text-white';
            if (fearGreed.value <= 20) fgClass = 'text-orange-500';
            else if (fearGreed.value <= 40) fgClass = 'text-orange-500';
            else if (fearGreed.value <= 60) fgClass = 'text-yellow-500';
            else if (fearGreed.value <= 80) fgClass = 'text-lime-500';
            else fgClass = 'text-green-500';
            
            fearGreedEl.textContent = fearGreed.value;
            fearGreedEl.className = `text-2xl font-bold ${fgClass}`;
          }
          
          if (fearGreedLabelEl) {
            fearGreedLabelEl.textContent = fearGreed.classification || '--';
          }
          
          if (fearGreedUpdateEl) {
            const now = new Date();
            fearGreedUpdateEl.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
          }
          
          addLog('success', 'æè´ªæŒ‡æ•°å·²æ›´æ–°');
        } else {
          addLog('warning', 'æè´ªæŒ‡æ•°æ•°æ®ä¸ºç©º');
        }

        // è·å–çƒ­é—¨æœç´¢
        const trendingCoins = await fetchTrendingCoins();
        const trendingContainer = document.getElementById('marketTrending');
        
        addLog('info', `çƒ­é—¨ä»£å¸æ•°é‡: ${trendingCoins.length}`);

        if (trendingCoins.length > 0 && trendingContainer) {
          trendingContainer.innerHTML = trendingCoins.map((item, index) => {
            // Coinloreè¿”å›çš„æ•°æ®ç»“æ„æ˜¯æ‰å¹³çš„ï¼Œç›´æ¥ä½¿ç”¨item
            // CoinGeckoè¿”å›çš„æ•°æ®ç»“æ„æ˜¯ { item: { ... } }
            const coin = item.item || item;  // å…¼å®¹ä¸¤ç§æ ¼å¼
            
            if (!coin) return '';
            
            const coinSymbol = coin.symbol || '';
            const coinName = coin.name || '';
            const coinThumb = coin.thumb || coin.icon || '';
            const coinRank = coin.market_cap_rank || coin.rank || 'N/A';
            
            const isAnomaly = anomalySignals.some(signal => 
              coinSymbol && signal.symbol.toLowerCase().includes(coinSymbol.toLowerCase())
            );

            return `
              <div class="flex items-center justify-between ${isAnomaly ? 'bg-yellow-500/20' : ''}">
                <div class="flex items-center gap-1.5">
                  <span class="text-slate-500">${index + 1}.</span>
                  ${coinThumb ? `<img src="${coinThumb}" alt="${coinName}" class="w-4 h-4 rounded-full" />` : ''}
                  <span class="text-white">${coinSymbol}</span>
                  ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                </div>
                <span class="text-slate-500">#${coinRank}</span>
              </div>
            `;
          }).join('');
          addLog('success', 'çƒ­é—¨ä»£å¸åˆ—è¡¨å·²æ›´æ–°');
        } else if (trendingContainer) {
          trendingContainer.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— æ•°æ®</div>';
          addLog('warning', 'çƒ­é—¨ä»£å¸åˆ—è¡¨ä¸ºç©º');
        } else {
          addLog('error', 'æ‰¾ä¸åˆ°marketTrendingå…ƒç´ ');
        }

        // æ›´æ–°æ’è¡Œæ¦œï¼ˆæ¶¨å¹…æ¦œã€æˆäº¤é‡æ¦œã€å¼‚åŠ¨æ¦œï¼‰
        if (binancePrices.length > 0) {
          // 24hæ¶¨å¹…æ¦œTOP10
          const topGainersContainer = document.getElementById('topGainers');
          const topGainersData = [...binancePrices]
            .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
            .slice(0, 10);
          
          if (topGainersContainer) {
            topGainersContainer.innerHTML = topGainersData.map((item, index) => {
              const isAnomaly = anomalySignals.some(s => s.symbol === item.symbol);
              return `
                <div class="flex items-center justify-between ${isAnomaly ? 'bg-yellow-500/20' : ''}">
                  <div class="flex items-center gap-1.5">
                    <span class="text-slate-500">${index + 1}.</span>
                    <span class="text-white">${item.symbol.replace('USDT', '')}</span>
                    ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                  </div>
                  <span class="text-green-500">+${item.priceChangePercent.toFixed(2)}%</span>
                </div>
              `;
            }).join('');
            addLog('success', '24hæ¶¨å¹…æ¦œå·²æ›´æ–°');
          }

          // 24hæˆäº¤é‡æ¦œTOP10
          const topVolumeContainer = document.getElementById('topVolume');
          const topVolumeData = [...binancePrices]
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 10);
          
          if (topVolumeContainer) {
            topVolumeContainer.innerHTML = topVolumeData.map((item, index) => {
              const volumeInM = item.quoteVolume / 1000000;
              const isAnomaly = anomalySignals.some(s => s.symbol === item.symbol);
              return `
                <div class="flex items-center justify-between ${isAnomaly ? 'bg-yellow-500/20' : ''}">
                  <div class="flex items-center gap-1.5">
                    <span class="text-slate-500">${index + 1}.</span>
                    <span class="text-white">${item.symbol.replace('USDT', '')}</span>
                    ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                  </div>
                  <span class="text-slate-400">${volumeInM.toFixed(0)}M</span>
                </div>
              `;
            }).join('');
            addLog('success', '24hæˆäº¤é‡æ¦œå·²æ›´æ–°');
          }

          // å¼‚åŠ¨æ¦œTOP10ï¼ˆæŒ‰å¼‚åŠ¨æ¬¡æ•°æ’åºï¼‰
          const topAnomaliesContainer = document.getElementById('topAnomalies');
          if (topAnomaliesContainer) {
            if (anomalySignals.length > 0) {
              const sortedAnomalies = [...anomalySignals]
                .sort((a, b) => (b.count || 1) - (a.count || 1))
                .slice(0, 10);
              
              topAnomaliesContainer.innerHTML = sortedAnomalies.map((signal, index) => {
                const directionIcon = signal.direction === 'up' ? 'ğŸ“ˆ' : 'ğŸ“‰';
                const directionColor = signal.direction === 'up' ? 'text-green-500' : 'text-orange-500';
                const changeClass = signal.change24h >= 0 ? 'text-green-500' : 'text-orange-500';
                const changePrefix = signal.change24h >= 0 ? '+' : '';
                
                return `
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-1.5">
                      <span class="text-slate-500">${index + 1}.</span>
                      <span class="${directionColor}">${directionIcon}</span>
                      <span class="text-white">${signal.symbol.replace('USDT', '')}</span>
                      ${signal.count > 1 ? `<span class="text-xs bg-yellow-500/30 text-yellow-400 px-1 rounded">x${signal.count}</span>` : ''}
                    </div>
                    <span class="${changeClass}">${changePrefix}${signal.change24h.toFixed(2)}%</span>
                  </div>
                `;
              }).join('');
              addLog('success', 'å¼‚åŠ¨æ¦œå·²æ›´æ–°');
            } else {
              topAnomaliesContainer.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨</div>';
            }
          }
        } else {
          // äº¤æ˜“å¯¹æ•°æ®ä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
          const containers = ['topGainers', 'topVolume', 'topAnomalies'];
          containers.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.innerHTML = '<div class="text-slate-500 text-center py-2">ç­‰å¾…äº¤æ˜“å¯¹æ•°æ®...</div>';
            }
          });
          addLog('warning', 'äº¤æ˜“å¯¹æ•°æ®ä¸ºç©ºï¼Œè¯·åˆ·æ–°é¡µé¢');
        }

        // æ›´æ–°å¼‚åŠ¨åˆ†å¸ƒ
        if (anomalySignals.length > 0) {
          // æŒ‰åˆ†ç±»ç»Ÿè®¡
          const categoryMap = new Map();
          // æŒ‰å¼‚åŠ¨ç±»å‹ç»Ÿè®¡
          const typeMap = new Map();
          // æŒ‰ä»·æ ¼åŒºé—´ç»Ÿè®¡
          const priceRangeMap = new Map();

          for (const signal of anomalySignals) {
            // è·å–ä»£å¸åˆ†ç±»ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸è°ƒç”¨CoinGecko APIï¼‰
            // æ ¹æ®å¸ç§åç§°è¿›è¡Œç®€å•åˆ†ç±»
            let categories = ['å…¶ä»–'];
            const symbol = signal.symbol.replace('USDT', '').toUpperCase();
            
            // ç®€å•åˆ†ç±»è§„åˆ™
            if (['BTC', 'ETH', 'BNB', 'SOL', 'ADA', 'XRP', 'DOT', 'MATIC', 'AVAX', 'LINK'].includes(symbol)) {
              categories = ['ä¸»æµå¸'];
            } else if (symbol.includes('MEME') || symbol.includes('DOGE') || symbol.includes('SHIB') || symbol.includes('PEPE') || symbol.includes('FLOKI')) {
              categories = ['Meme'];
            } else if (symbol.includes('AI') || symbol.includes('FET') || symbol.includes('RNDR') || symbol.includes('WLD')) {
              categories = ['AI'];
            } else if (symbol.includes('GAMING') || symbol.includes('GAME') || symbol.includes('IMX') || symbol.includes('SAND')) {
              categories = ['GameFi'];
            } else if (symbol.includes('DEFI') || symbol.includes('UNI') || symbol.includes('AAVE') || symbol.includes('CRV')) {
              categories = ['DeFi'];
            } else if (symbol.includes('L2') || symbol.includes('OP') || symbol.includes('ARB') || symbol.includes('MANTLE')) {
              categories = ['Layer 2'];
            }

            // ç»Ÿè®¡åˆ†ç±»
            categories.forEach(category => {
              const count = categoryMap.get(category) || 0;
              categoryMap.set(category, count + 1);
            });

            // ç»Ÿè®¡å¼‚åŠ¨ç±»å‹
            const typeKey = signal.strategy || 'unknown';
            const typeCount = typeMap.get(typeKey) || 0;
            typeMap.set(typeKey, typeCount + 1);

            // ç»Ÿè®¡ä»·æ ¼åŒºé—´
            const price = parseFloat(signal.price);
            let priceRange;
            if (price < 0.01) priceRange = '< $0.01';
            else if (price < 0.1) priceRange = '$0.01-$0.1';
            else if (price < 1) priceRange = '$0.1-$1';
            else if (price < 10) priceRange = '$1-$10';
            else if (price < 100) priceRange = '$10-$100';
            else priceRange = '> $100';
            
            const priceCount = priceRangeMap.get(priceRange) || 0;
            priceRangeMap.set(priceRange, priceCount + 1);
          }

          // æ›´æ–°æŒ‰åˆ†ç±»ç»Ÿè®¡
          const anomalyByCategoryEl = document.getElementById('anomalyByCategory');
          if (anomalyByCategoryEl) {
            const categoryDistribution = Array.from(categoryMap.entries())
              .map(([category, count]) => ({ category, count }))
              .sort((a, b) => b.count - a.count);
            
            if (categoryDistribution.length > 0) {
              const maxCount = categoryDistribution[0].count;
              anomalyByCategoryEl.innerHTML = categoryDistribution.map(({ category, count }) => {
                const percentage = (count / maxCount) * 100;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${category}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-slate-500 to-slate-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByCategoryEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— åˆ†ç±»æ•°æ®</div>';
            }
          }

          // æ›´æ–°æŒ‰ç±»å‹ç»Ÿè®¡
          const anomalyByTypeEl = document.getElementById('anomalyByType');
          if (anomalyByTypeEl) {
            const typeDistribution = Array.from(typeMap.entries())
              .map(([type, count]) => ({ type, count }))
              .sort((a, b) => b.count - a.count);

            const typeLabels = {
              'main_up': 'ä¸»åŠ›æ‹‰ç›˜',
              'main_down': 'ä¸»åŠ›ç ¸ç›˜',
              'fund_up': 'èµ„é‡‘æ‹‰ç›˜',
              'fund_down': 'èµ„é‡‘ç ¸ç›˜',
              'unknown': 'æœªçŸ¥'
            };

            if (typeDistribution.length > 0) {
              const maxCount = typeDistribution[0].count;
              anomalyByTypeEl.innerHTML = typeDistribution.map(({ type, count }) => {
                const percentage = (count / maxCount) * 100;
                const label = typeLabels[type] || type;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${label}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-emerald-500 to-teal-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByTypeEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— ç±»å‹æ•°æ®</div>';
            }
          }

          // æ›´æ–°æŒ‰ä»·æ ¼åŒºé—´ç»Ÿè®¡
          const anomalyByPriceEl = document.getElementById('anomalyByPrice');
          if (anomalyByPriceEl) {
            const priceDistribution = Array.from(priceRangeMap.entries())
              .map(([range, count]) => ({ range, count }))
              .sort((a, b) => b.count - a.count);

            if (priceDistribution.length > 0) {
              const maxCount = priceDistribution[0].count;
              anomalyByPriceEl.innerHTML = priceDistribution.map(({ range, count }) => {
                const percentage = (count / maxCount) * 100;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${range}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-yellow-500 to-orange-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByPriceEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— ä»·æ ¼æ•°æ®</div>';
            }
          }

          // æ›´æ–°ä»Šæ—¥å¼‚åŠ¨æ±‡æ€»
          const todayAnomalySummaryEl = document.getElementById('todayAnomalySummary');
          if (todayAnomalySummaryEl) {
            const todaySignals = anomalySignals.filter(s => {
              const signalDate = new Date(s.timestamp);
              const today = new Date();
              return signalDate.getDate() === today.getDate() && 
                     signalDate.getMonth() === today.getMonth() && 
                     signalDate.getFullYear() === today.getFullYear();
            });

            const summaryData = {
              totalCount: todaySignals.length,
              upCount: todaySignals.filter(s => s.direction === 'up').length,
              downCount: todaySignals.filter(s => s.direction === 'down').length,
              fundCount: todaySignals.filter(s => s.strategy && s.strategy.includes('fund')).length,
              mainCount: todaySignals.filter(s => s.strategy && s.strategy.includes('main')).length
            };

            todayAnomalySummaryEl.innerHTML = `
              <div class="grid grid-cols-2 gap-2">
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-white">${summaryData.totalCount}</div>
                  <div class="text-xs text-slate-400">æ€»å¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-green-500">${summaryData.upCount}</div>
                  <div class="text-xs text-slate-400">å‘ä¸Šå¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-orange-500">${summaryData.downCount}</div>
                  <div class="text-xs text-slate-400">å‘ä¸‹å¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-yellow-500">${summaryData.fundCount}</div>
                  <div class="text-xs text-slate-400">èµ„é‡‘å¼‚åŠ¨</div>
                </div>
              </div>
            `;
          }

          addLog('success', 'å¼‚åŠ¨åˆ†å¸ƒå·²æ›´æ–°');
        } else {
          document.getElementById('anomalyByCategory').innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';
          document.getElementById('anomalyByType').innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';
          document.getElementById('anomalyByPrice').innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';
          document.getElementById('todayAnomalySummary').innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';
        }

      } catch (error) {
        console.error('åˆ·æ–°å¸‚åœºæ•°æ®å¤±è´¥:', error);
      }
    }

    // è·å–é“¾ä¸Šæ± å­æ•°æ®
    async function fetchOnchainPools() {
      try {
        addLog('info', 'å¼€å§‹åŠ è½½é“¾ä¸Šæ± å­æ•°æ®...');

        // è·å–ä»¥å¤ªåŠçƒ­é—¨æ± 
        await fetchNetworkPools('eth', 'ethTopPools');

        // è·å–BSCçƒ­é—¨æ± 
        await fetchNetworkPools('bsc', 'bscTopPools');

        addLog('success', 'é“¾ä¸Šæ± å­æ•°æ®åŠ è½½å®Œæˆ');
      } catch (error) {
        addLog('error', 'é“¾ä¸Šæ± å­æ•°æ®åŠ è½½å¤±è´¥', error.message);
      }
    }

    // è·å–æŒ‡å®šç½‘ç»œçš„æ± å­æ•°æ®
    async function fetchNetworkPools(network, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        addLog('error', `æ‰¾ä¸åˆ°${containerId}å…ƒç´ `);
        return;
      }

      try {
        // ä½¿ç”¨CoinGeckoé“¾ä¸ŠAPI
        const apiUrl = `https://api.geckoterminal.com/api/v2/networks/${network}/trending_pools`;

        const response = await fetchWithRetry(apiUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false); // GeckoTerminalä¸éœ€è¦ä»£ç†

        if (!response.ok) {
          addLog('warning', `${network.toUpperCase()}æ± å­APIè¿”å›é”™è¯¯: ${response.status}`);
          container.innerHTML = '<div class="text-slate-500 text-center py-2">åŠ è½½å¤±è´¥</div>';
          return;
        }

        const json = await response.json();

        if (!json || !json.data) {
          addLog('warning', `${network.toUpperCase()}æ± å­æ•°æ®ä¸ºç©º`);
          container.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— æ•°æ®</div>';
          return;
        }

        const pools = json.data;

        if (pools.length === 0) {
          container.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— æ•°æ®</div>';
          return;
        }

        // æ˜¾ç¤ºå‰10ä¸ªæ± å­
        const topPools = pools.slice(0, 10);

        container.innerHTML = topPools.map((pool, index) => {
          const attributes = pool.attributes;
          const poolAddress = attributes.address || '';
          const name = attributes.name || attributes.address?.substring(0, 8) + '...' || 'æœªçŸ¥æ± å­';
          const dex = attributes.dex?.name || attributes.exchange_name || 'Unknown';
          const dexName = attributes.dex?.address || '';
          
          // æ”¯æŒå¤šç§æ•°æ®ç»“æ„æå–ä»£å¸ç¬¦å·
          let baseToken = '?';
          let quoteToken = '?';
          let baseTokenAddress = '';
          let baseTokenName = '';

          if (attributes.base_token) {
            baseToken = attributes.base_token.symbol || attributes.base_token.name || '?';
            baseTokenAddress = attributes.base_token.address || '';
            baseTokenName = attributes.base_token.name || baseToken;
          } else if (attributes.token0) {
            baseToken = attributes.token0.symbol || attributes.token0.name || '?';
            baseTokenAddress = attributes.token0.address || '';
            baseTokenName = attributes.token0.name || baseToken;
          }

          if (attributes.quote_token) {
            quoteToken = attributes.quote_token.symbol || attributes.quote_token.name || '?';
          } else if (attributes.token1) {
            quoteToken = attributes.token1.symbol || attributes.token1.name || '?';
          }

          // ä»åç§°ä¸­æå–äº¤æ˜“å¯¹ï¼ˆå¦‚æœAPIæ•°æ®ä¸å®Œæ•´ï¼‰
          if ((baseToken === '?' || quoteToken === '?') && name.includes('/')) {
            const parts = name.split('/');
            if (parts.length >= 2) {
              if (baseToken === '?') baseToken = parts[0].trim();
              if (quoteToken === '?') quoteToken = parts[1].trim();
            }
          }

          const reserveInUsd = attributes.reserve_in_usd || 0;
          const volume24h = attributes.volume_usd?.h24 || 0;
          const txCount = attributes.tx_count?.h24 || 0;

          const tvlInM = reserveInUsd / 1000000;
          const volume24hInM = volume24h / 1000000;

          return `
            <div class="bg-slate-800/50 rounded p-2 cursor-pointer hover:bg-slate-700/50 transition-colors" onclick="showPoolDetail('${poolAddress}', '${baseTokenAddress}', '${network}')">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-1">
                  <span class="text-slate-500">${index + 1}.</span>
                  <span class="text-white text-xs font-medium">${name}</span>
                  <span class="text-xs text-emerald-400">ğŸ”</span>
                </div>
                <span class="text-xs text-slate-400">${dex}</span>
              </div>
              <div class="flex items-center gap-1 text-xs mb-1">
                <span class="text-slate-400">${baseToken}/${quoteToken}</span>
              </div>
              <div class="grid grid-cols-2 gap-2 text-xs">
                <div>
                  <span class="text-slate-500">TVL:</span>
                  <span class="text-white ml-1">$${tvlInM.toFixed(2)}M</span>
                </div>
                <div class="text-right">
                  <span class="text-slate-500">24hé‡:</span>
                  <span class="text-white">$${volume24hInM.toFixed(2)}M</span>
                </div>
              </div>
            </div>
          `;
        }).join('');

        addLog('success', `${network.toUpperCase()}çƒ­é—¨æ± å·²æ›´æ–°ï¼Œå…±${topPools.length}ä¸ª`);
      } catch (error) {
        addLog('error', `${network.toUpperCase()}æ± å­æ•°æ®è·å–å¤±è´¥`, error.message);
        container.innerHTML = '<div class="text-slate-500 text-center py-2">åŠ è½½å¤±è´¥</div>';
      }
    }

    // è·å–åˆçº¦è¡Œæƒ…æ•°æ®ï¼ˆæ”¯æŒå¤šä¸ªAPIæä¾›å•†ï¼‰
    async function fetchBinancePrices() {
      try {
        let apiUrl, apiName, response, data;

        addLog('api', `æ­£åœ¨è¿æ¥${currentApiProvider.toUpperCase()}å…¬å…±API...`);
        
        if (currentApiProvider === 'okx') {
          // OKX API
          apiUrl = 'https://www.okx.com/api/v5/market/tickers?instType=SWAP';
          apiName = 'OKX';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);  // OKXæ”¯æŒCORSï¼Œä¸éœ€è¦ä»£ç†

          if (!response.ok) {
            const errorMsg = `OKX APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          const json = await response.json();

          if (!json || json.code !== "0") {
            addLog('error', `OKX APIè¿”å›é”™è¯¯: ${json.msg || 'æœªçŸ¥é”™è¯¯'}`, `é”™è¯¯ç : ${json.code}`);
            return;
          }

          data = json.data;

          if (!Array.isArray(data)) {
            addLog('error', 'OKX APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `OKX APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢OKXæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.instId.endsWith('USDT-SWAP') &&
              parseFloat(item.volCcy24h) > 10000000
            )
            .sort((a, b) => parseFloat(b.volCcy24h) - parseFloat(a.volCcy24h))
            .map(item => {
              const priceChange = parseFloat(item.last) - parseFloat(item.open24h);
              const priceChangePercent = (parseFloat(item.last) - parseFloat(item.open24h)) / parseFloat(item.open24h) * 100;

              return {
                symbol: item.instId.replace('-USDT-SWAP', 'USDT'),
                price: item.last,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.vol24h,
                quoteVolume: item.volCcy24h
              };
            });

          binancePrices = qualifiedSymbols;

        } else if (currentApiProvider === 'binance') {
          // Binance API
          apiUrl = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
          apiName = 'Binance';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, true);

          if (!response.ok) {
            const errorMsg = `Binance APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          data = await response.json();

          if (!Array.isArray(data)) {
            addLog('error', 'Binance APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `Binance APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢Binanceæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.symbol.endsWith('USDT') &&
              parseFloat(item.quoteVolume) > 10000000
            )
            .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
            .map(item => ({
              symbol: item.symbol,
              price: item.lastPrice,
              priceChange: item.priceChange,
              priceChangePercent: item.priceChangePercent,
              volume: item.volume,
              quoteVolume: item.quoteVolume
            }));

          binancePrices = qualifiedSymbols;

        } else if (currentApiProvider === 'bybit') {
          // Bybit API
          apiUrl = 'https://api.bybit.com/v5/market/tickers?category=linear';
          apiName = 'Bybit';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);  // Bybitæ”¯æŒCORSï¼Œä¸éœ€è¦ä»£ç†

          if (!response.ok) {
            const errorMsg = `Bybit APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          const json = await response.json();

          if (!json || json.retCode !== 0) {
            addLog('error', `Bybit APIè¿”å›é”™è¯¯: ${json.retMsg || 'æœªçŸ¥é”™è¯¯'}`, `é”™è¯¯ç : ${json.retCode}`);
            return;
          }

          data = json.result.list;

          if (!Array.isArray(data)) {
            addLog('error', 'Bybit APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `Bybit APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢Bybitæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.symbol.endsWith('USDT') &&
              parseFloat(item.turnover24h) > 10000000
            )
            .sort((a, b) => parseFloat(b.turnover24h) - parseFloat(a.turnover24h))
            .map(item => {
              const priceChangePercent = parseFloat(item.price24hPcnt) * 100;
              const price = parseFloat(item.lastPrice);
              const priceChange = price * priceChangePercent / 100;

              return {
                symbol: item.symbol,
                price: item.lastPrice,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.volume24h,
                quoteVolume: item.turnover24h
              };
            });

          binancePrices = qualifiedSymbols;
        }

        const logDetails = `æ€»äº¤æ˜“å¯¹: ${data.length}ä¸ª | ç¬¦åˆ>10Mæ¡ä»¶: ${binancePrices.length}ä¸ª | é¡¶éƒ¨3: ${binancePrices.slice(0, 3).map(s => s.symbol).join(', ')}`;
        addLog('info', logDetails);

        // ä¿å­˜äº¤æ˜“å¯¹æ•°æ®åˆ°localStorage
        saveTickerData();

      } catch (error) {
        const errorMsg = `${currentApiProvider.toUpperCase()} APIè¿æ¥å¤±è´¥: ${error.message}`;
        addLog('error', errorMsg);

        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–CORSé”™è¯¯ï¼Œç»™å‡ºæ›´è¯¦ç»†çš„æç¤º
        if (error.message.includes('CORS') || error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          addLog('warning', 'å¯èƒ½æ˜¯CORSé”™è¯¯ï¼Œå°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
          addLog('warning', 'å½“å‰ä½¿ç”¨å…¬å…±ä»£ç†: ' + CORS_PROXIES[currentProxyIndex % CORS_PROXIES.length]);
        } else if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {
          addLog('warning', 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
        } else if (error.message.includes('ECONNREFUSED')) {
          addLog('warning', 'è¿æ¥è¢«æ‹’ç»ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–ä»£ç†ä¸å¯ç”¨');
        }

        // è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPIæä¾›å•†
        const apiProviders = ['okx', 'binance', 'bybit'];
        const currentIndex = apiProviders.indexOf(currentApiProvider);
        if (currentIndex !== -1 && currentIndex < apiProviders.length - 1) {
          const nextProvider = apiProviders[currentIndex + 1];
          addLog('info', `è‡ªåŠ¨åˆ‡æ¢åˆ° ${nextProvider.toUpperCase()} API...`);
          currentApiProvider = nextProvider;
          
          // é€’å½’è°ƒç”¨ï¼Œå°è¯•ä¸‹ä¸€ä¸ªAPI
          setTimeout(() => {
            fetchBinancePrices();
          }, 1000);
        } else {
          // æ‰€æœ‰APIéƒ½å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰
          if (binancePrices.length > 0) {
            addLog('warning', 'æ‰€æœ‰APIå‡å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®');
          } else {
            addLog('error', 'æ‰€æœ‰APIå‡å¤±è´¥ä¸”æ— ç¼“å­˜æ•°æ®');
          }
        }

        console.error(`âŒ [${currentApiProvider.toUpperCase()} API] è¿æ¥å¤±è´¥:`, error);
      }
    }

    // è·å–å¼‚åŠ¨ä¿¡å·ï¼ˆå®æ—¶åˆ†æï¼‰
    async function fetchAnomalySignals() {
      try {
        updateAnomalyStatus('analyzing');
        addLog('info', 'å¼€å§‹åˆ†æå¸‚åœºå¼‚åŠ¨...');

        // åŸºäºå®æ—¶è¡Œæƒ…æ•°æ®è¿›è¡Œåˆ†æ
        const newSignals = await analyzeAnomalies(binancePrices);

        // åˆå¹¶æ–°ä¿¡å·åˆ°ç°æœ‰ä¿¡å·ä¸­ï¼ˆå»é‡ï¼šç›¸åŒäº¤æ˜“å¯¹ç´¯åŠ æ¬¡æ•°ï¼‰
        const signalMap = new Map();

        // å…ˆæ·»åŠ æ—§ä¿¡å·
        anomalySignals.forEach(signal => {
          signalMap.set(signal.symbol, signal);
        });

        // å†æ·»åŠ æ–°ä¿¡å·ï¼ˆç›¸åŒäº¤æ˜“å¯¹ç´¯åŠ æ¬¡æ•°ï¼Œä½†5åˆ†é’Ÿå†…ä¸é‡å¤ï¼‰
        newSignals.forEach(signal => {
          const existing = signalMap.get(signal.symbol);
          if (existing) {
            // æ£€æŸ¥è·ç¦»ä¸Šæ¬¡å¼‚åŠ¨æ˜¯å¦è¶…è¿‡5åˆ†é’Ÿ
            const existingTime = new Date(existing.timestamp).getTime();
            const newTime = new Date(signal.timestamp).getTime();
            const timeDiff = newTime - existingTime;

            if (timeDiff >= 300000) { // 5åˆ†é’Ÿ = 300000æ¯«ç§’
              // è¶…è¿‡5åˆ†é’Ÿï¼Œç´¯åŠ æ¬¡æ•°
              existing.count = (existing.count || 1) + 1;
            }

            // å§‹ç»ˆæ›´æ–°å…¶ä»–æ•°æ®
            existing.price = signal.price;
            existing.change24h = signal.change24h;
            existing.volume = signal.volume;
            existing.timestamp = signal.timestamp;
            existing.direction = signal.direction;
            existing.strategy = signal.strategy;
          } else {
            // æ–°ä¿¡å·ï¼Œåˆå§‹åŒ–æ¬¡æ•°ä¸º1
            signal.count = 1;
            signalMap.set(signal.symbol, signal);
          }
        });

        // è½¬æ¢å›æ•°ç»„
        anomalySignals = Array.from(signalMap.values());

        addLog('success', `å¼‚åŠ¨åˆ†æå®Œæˆï¼Œå‘ç° ${newSignals.length} ä¸ªæ–°å¼‚åŠ¨ä¿¡å·ï¼Œæ€»è®¡ ${anomalySignals.length} ä¸ª`);

        // è‡ªåŠ¨è·å–å¹¶ç¼“å­˜æ–°å¼‚åŠ¨ä¿¡å·çš„å¸ç§è¯¦æƒ…æ•°æ®
        if (newSignals.length > 0) {
          addLog('info', 'å¼€å§‹è·å– ' + newSignals.length + ' ä¸ªæ–°å¼‚åŠ¨ä¿¡å·çš„å¸ç§è¯¦æƒ…æ•°æ®...');
          const cachePromises = newSignals.map(async (signal) => {
            const symbol = signal.symbol;
            // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
            if (!coinDetailCache.has(symbol)) {
              addLog('info', 'è·å– ' + symbol + ' å¸ç§è¯¦æƒ…...');
              const coinGeckoInfo = await fetchCoinGeckoInfo(symbol);
              if (coinGeckoInfo) {
                coinDetailCache.set(symbol, {
                  coinGecko: coinGeckoInfo,
                  volume: null,
                  timestamp: Date.now()
                });
              }
            }
          });
          await Promise.all(cachePromises);
          addLog('success', 'æ–°å¼‚åŠ¨ä¿¡å·å¸ç§è¯¦æƒ…æ•°æ®è·å–å®Œæˆ');
        }

        updateAnomalyView();
        saveAnomalySignals();

      } catch (error) {
        addLog('error', 'å¼‚åŠ¨åˆ†æå¤±è´¥', error.message);
        console.error('âŒ [å¼‚åŠ¨åˆ†æ] å¤±è´¥:', error);
      } finally {
        updateAnomalyStatus('idle');
      }
    }

    // å¼‚åŠ¨ä¿¡å·åˆ†æç®—æ³•
    async function analyzeAnomalies(prices) {
      const signals = [];
      let scanned = prices.length;
      let analyzed = 0;
      let mainUpCount = 0;
      let mainDownCount = 0;
      let fundUpCount = 0;
      let fundDownCount = 0;

      addLog('info', `å¼€å§‹åˆ†æ ${scanned} ä¸ªäº¤æ˜“å¯¹...`);

      for (const item of prices) {
        const price = parseFloat(item.price);
        const change24h = parseFloat(item.priceChangePercent);
        const volume = parseFloat(item.quoteVolume);
        const volumeInM = volume / 1000000;

        // ç­›é€‰æˆäº¤é‡ > 10M çš„äº¤æ˜“å¯¹
        if (volumeInM <= 10) {
          continue;
        }

        analyzed++;

        // æ·»åŠ å®æ—¶åˆ†ææ—¥å¿—
        addLog('info', `æ­£åœ¨åˆ†æ: ${item.symbol}...`);

        // è·å–50æ ¹Kçº¿æ•°æ®ï¼ˆä½¿ç”¨5åˆ†é’ŸKçº¿ï¼‰
        const klineData = await fetchKlineData(item.symbol, '5m');

        if (!klineData) {
          continue;
        }

        // å¼‚åŠ¨åˆ¤æ–­é€»è¾‘ï¼šç¬¬49æ ¹æˆ–ç¬¬50æ ¹Kçº¿é«˜ä½ç‚¹çªç ´å‰48æ ¹çš„2%
        let hasAnomaly = false;
        let strategy = null;
        let breakthrough = '';
        let hasVolumeSpike = klineData.volumeSpike >= 10.0;

        // åˆ¤æ–­æ˜¯å¦çªç ´é«˜ç‚¹2%ï¼ˆç¬¬49æ ¹æˆ–ç¬¬50æ ¹ï¼‰
        if (klineData.k49High > klineData.maxHigh48 * 1.02 || klineData.k50High > klineData.maxHigh48 * 1.02) {
          hasAnomaly = true;
          // æ ¹æ®æ”¾é‡åˆ¤æ–­ä¿¡å·ç±»å‹
          if (hasVolumeSpike) {
            strategy = 'fund_up';
            fundUpCount++;
          } else {
            strategy = 'main_up';
            mainUpCount++;
          }

          const whichKline = klineData.k49High > klineData.maxHigh48 * 1.02 ? 'ç¬¬49æ ¹' : 'ç¬¬50æ ¹';
          const breakthroughValue = klineData.k49High > klineData.maxHigh48 * 1.02
            ? ((klineData.k49High / klineData.maxHigh48 - 1) * 100).toFixed(2)
            : ((klineData.k50High / klineData.maxHigh48 - 1) * 100).toFixed(2);
          breakthrough = `${whichKline}çªç ´å‰48æ ¹Kçº¿é«˜ç‚¹ ${klineData.maxHigh48.toFixed(2)} (+${breakthroughValue}%)`;
        }
        // åˆ¤æ–­æ˜¯å¦è·Œç ´ä½ç‚¹2%ï¼ˆç¬¬49æ ¹æˆ–ç¬¬50æ ¹ï¼‰
        else if (klineData.k49Low < klineData.minLow48 * 0.98 || klineData.k50Low < klineData.minLow48 * 0.98) {
          hasAnomaly = true;
          // æ ¹æ®æ”¾é‡åˆ¤æ–­ä¿¡å·ç±»å‹
          if (hasVolumeSpike) {
            strategy = 'fund_down';
            fundDownCount++;
          } else {
            strategy = 'main_down';
            mainDownCount++;
          }

          const whichKline = klineData.k49Low < klineData.minLow48 * 0.98 ? 'ç¬¬49æ ¹' : 'ç¬¬50æ ¹';
          const breakthroughValue = klineData.k49Low < klineData.minLow48 * 0.98
            ? ((klineData.k49Low / klineData.minLow48 - 1) * 100).toFixed(2)
            : ((klineData.k50Low / klineData.minLow48 - 1) * 100).toFixed(2);
          breakthrough = `${whichKline}è·Œç ´å‰48æ ¹Kçº¿ä½ç‚¹ ${klineData.minLow48.toFixed(2)} (${breakthroughValue}%)`;
        }

        if (hasAnomaly) {
          const strategyTextMap = {
            'main_up': 'ä¸»åŠ›å¼‚åŠ¨æ‹‰ç›˜',
            'main_down': 'ä¸»åŠ›å¼‚åŠ¨ç ¸ç›˜',
            'fund_up': 'èµ„é‡‘å¼‚åŠ¨æ‹‰ç›˜',
            'fund_down': 'èµ„é‡‘å¼‚åŠ¨ç ¸ç›˜'
          };
          const strategyText = strategyTextMap[strategy] || strategy;
          addLog('warning', `å‘ç°å¼‚åŠ¨ä¿¡å·: ${item.symbol}`, `${strategyText} | ${breakthrough}`);

          signals.push({
            symbol: item.symbol,
            price: price,
            change24h: change24h,
            volume: volumeInM,
            direction: (strategy === 'main_up' || strategy === 'fund_up') ? 'up' : 'down',
            breakthrough: breakthrough,
            volumeSpike: klineData.volumeSpike.toFixed(1) + 'x',
            maxHigh: klineData.maxHigh48.toFixed(2),
            minLow: klineData.minLow48.toFixed(2),
            targetPrice: (strategy === 'main_up' || strategy === 'fund_up') ? (price * 1.05).toFixed(2) : (price * 0.95).toFixed(2),
            targetKline: '5m',
            hasVolume: hasVolumeSpike,
            strategy: strategy,
            timestamp: new Date().toISOString()
          });
        }
      }

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      const scannedCountEl = document.getElementById('scannedCount');
      const analyzedCountEl = document.getElementById('analyzedCount');
      const totalSignalsEl = document.getElementById('totalSignals');
      const mainUpCountEl = document.getElementById('mainUpCount');
      const mainDownCountEl = document.getElementById('mainDownCount');
      const fundUpCountEl = document.getElementById('fundUpCount');
      const fundDownCountEl = document.getElementById('fundDownCount');

      if (scannedCountEl) scannedCountEl.textContent = scanned;
      if (analyzedCountEl) analyzedCountEl.textContent = analyzed;
      if (totalSignalsEl) totalSignalsEl.textContent = signals.length;
      if (mainUpCountEl) mainUpCountEl.textContent = mainUpCount;
      if (mainDownCountEl) mainDownCountEl.textContent = mainDownCount;
      if (fundUpCountEl) fundUpCountEl.textContent = fundUpCount;
      if (fundDownCountEl) fundDownCountEl.textContent = fundDownCount;

      const analysisStats = document.getElementById('analysisStats');
      if (analysisStats) {
        analysisStats.classList.remove('hidden');
      }

      return signals;
    }

    // è·å–Kçº¿æ•°æ®ï¼ˆå¢é‡æ›´æ–°æ¨¡å¼ï¼Œä¿æŒ51æ ¹æ»‘åŠ¨çª—å£ï¼‰
    async function fetchKlineData(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();
      const klineWindowSize = 51; // æ»‘åŠ¨çª—å£å¤§å°

      try {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
        if (klineCache.has(cacheKey)) {
          const cached = klineCache.get(cacheKey);

          // æ£€æŸ¥æœ€æ–°Kçº¿æ˜¯å¦å·²è¿‡æœŸï¼ˆè¶…è¿‡ä¸€ä¸ªKçº¿å‘¨æœŸï¼‰
          const latestKlineTime = cached.data[cached.data.length - 1][0];
          const nextKlineTime = latestKlineTime + (interval === '5m' ? 5 * 60 * 1000 : 60 * 1000);

          if (now < nextKlineTime) {
            // æœ€æ–°Kçº¿è¿˜æœªè¿‡æœŸï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜
            return calculateKlineMetrics(cached.data);
          }

          // å¢é‡æ›´æ–°ï¼šè·å–1æ ¹æœ€æ–°Kçº¿
          try {
            let apiUrl;
            if (currentApiProvider === 'okx') {
              // OKX Kçº¿API
              const instId = symbol.replace('USDT', '-USDT-SWAP');
              apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=1`;
            } else if (currentApiProvider === 'binance') {
              // Binance Kçº¿API
              apiUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=1`;
            } else if (currentApiProvider === 'bybit') {
              // Bybit Kçº¿API
              apiUrl = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=1`;
            }

            const response = await fetch(apiUrl, { method: 'GET' });

            if (!response.ok) {
              return null;
            }

            let newData;
            if (currentApiProvider === 'okx') {
              const json = await response.json();
              newData = json.data;
            } else if (currentApiProvider === 'bybit') {
              const json = await response.json();
              newData = json.result.list;
            } else {
              newData = await response.json();
            }

            if (newData && newData.length > 0) {
              // OKXå’ŒBybitè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢
              let newKline;
              if (currentApiProvider === 'okx' || currentApiProvider === 'bybit') {
                newKline = [
                  parseInt(newData[0][0]), // æ—¶é—´æˆ³
                  parseFloat(newData[0][1]), // å¼€ç›˜ä»·
                  parseFloat(newData[0][2]), // æœ€é«˜ä»·
                  parseFloat(newData[0][3]), // æœ€ä½ä»·
                  parseFloat(newData[0][4]), // æ”¶ç›˜ä»·
                  parseFloat(newData[0][5])  // æˆäº¤é‡
                ];
              } else {
                newKline = newData[0];
              }

              const newKlineTime = newKline[0];
              const lastCachedTime = cached.data[cached.data.length - 1][0];

              // æ£€æŸ¥æ–°Kçº¿æ˜¯å¦ä¸ç¼“å­˜æœ€åä¸€æ¡é‡å¤
              if (newKlineTime === lastCachedTime) {
                // é‡å¤ï¼Œä½¿ç”¨ç¼“å­˜çš„æœ€åä¸€æ¡ï¼ˆæ›´æ–°æœ€æ–°æ•°æ®ï¼‰
                cached.data[cached.data.length - 1] = newKline;
              } else if (newKlineTime > lastCachedTime) {
                // æ–°Kçº¿æ—¶é—´æˆ³æ›´å¤§ï¼Œè¿½åŠ å¹¶åˆ é™¤æœ€è¿œçš„ä¸€æ¡
                cached.data.push(newKline);
                if (cached.data.length > klineWindowSize) {
                  cached.data.shift(); // åˆ é™¤æœ€è¿œçš„ä¸€æ ¹
                }
              } else {
                // æ—¶é—´æˆ³å¼‚å¸¸ï¼Œé‡æ–°åˆå§‹åŒ–
                console.warn(`Kçº¿æ—¶é—´æˆ³å¼‚å¸¸: ${symbol}, é‡æ–°åˆå§‹åŒ–`);
                return await initializeKlineCache(symbol, interval);
              }

              // æ›´æ–°ç¼“å­˜æ—¶é—´æˆ³
              cached.timestamp = now;

              return calculateKlineMetrics(cached.data);
            }
          } catch (error) {
            console.error(`å¢é‡æ›´æ–°Kçº¿å¤±è´¥: ${symbol}`, error);
            // å¢é‡æ›´æ–°å¤±è´¥ï¼Œè¿”å›ç¼“å­˜æ•°æ®
            return calculateKlineMetrics(cached.data);
          }
        }

        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–è·å–51æ ¹Kçº¿
        return await initializeKlineCache(symbol, interval);

      } catch (error) {
        console.error(`è·å–Kçº¿æ•°æ®å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // åˆå§‹åŒ–Kçº¿ç¼“å­˜ï¼ˆè·å–51æ ¹Kçº¿ï¼‰
    async function initializeKlineCache(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();

      try {
        let apiUrl;
        if (currentApiProvider === 'okx') {
          // OKX Kçº¿API
          const instId = symbol.replace('USDT', '-USDT-SWAP');
          apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=51`;
        } else if (currentApiProvider === 'binance') {
          // Binance Kçº¿API
          apiUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=51`;
        } else if (currentApiProvider === 'bybit') {
          // Bybit Kçº¿API
          apiUrl = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=51`;
        }

        const response = await fetch(apiUrl, { method: 'GET' });

        if (!response.ok) {
          return null;
        }

        let data;
        if (currentApiProvider === 'okx') {
          const json = await response.json();
          data = json.data;
          // OKXè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢ä¸ºæ­£åº
          data = data.reverse().map(k => [
            parseInt(k[0]), // æ—¶é—´æˆ³
            parseFloat(k[1]), // å¼€ç›˜ä»·
            parseFloat(k[2]), // æœ€é«˜ä»·
            parseFloat(k[3]), // æœ€ä½ä»·
            parseFloat(k[4]), // æ”¶ç›˜ä»·
            parseFloat(k[5])  // æˆäº¤é‡
          ]);
        } else if (currentApiProvider === 'bybit') {
          const json = await response.json();
          data = json.result.list;
          // Bybitè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢ä¸ºæ­£åº
          data = data.reverse().map(k => [
            parseInt(k[0]), // æ—¶é—´æˆ³
            parseFloat(k[1]), // å¼€ç›˜ä»·
            parseFloat(k[2]), // æœ€é«˜ä»·
            parseFloat(k[3]), // æœ€ä½ä»·
            parseFloat(k[4]), // æ”¶ç›˜ä»·
            parseFloat(k[5])  // æˆäº¤é‡
          ]);
        } else {
          data = await response.json();
        }

        if (data && data.length >= 51) {
          // å­˜å…¥ç¼“å­˜
          klineCache.set(cacheKey, {
            data: data,
            timestamp: now
          });

          // æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆä¿ç•™æœ€è¿‘100ä¸ªäº¤æ˜“å¯¹çš„ç¼“å­˜ï¼‰
          if (klineCache.size > 100) {
            const keys = Array.from(klineCache.keys());
            const oldestKey = keys.reduce((oldest, key) => {
              return klineCache.get(key).timestamp < klineCache.get(oldest).timestamp ? key : oldest;
            }, keys[0]);
            klineCache.delete(oldestKey);
          }

          addLog('info', `åˆå§‹åŒ–Kçº¿ç¼“å­˜: ${symbol}, ${data.length}æ ¹Kçº¿`);
          return calculateKlineMetrics(data);
        }

        return null;
      } catch (error) {
        console.error(`åˆå§‹åŒ–Kçº¿ç¼“å­˜å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // è®¡ç®—Kçº¿æŒ‡æ ‡ï¼ˆä½¿ç”¨51æ ¹æ»‘åŠ¨çª—å£æ•°æ®ï¼šå‰48æ ¹ä½œä¸ºåŸºå‡†ï¼Œåˆ†æç¬¬49å’Œ50æ ¹ï¼‰
    function calculateKlineMetrics(data) {
      // å‰48æ ¹Kçº¿ä½œä¸ºåŸºå‡†
      const kline48Highs = data.slice(0, 48).map(k => parseFloat(k[2]));
      const kline48Lows = data.slice(0, 48).map(k => parseFloat(k[3]));
      const kline48Volumes = data.slice(0, 48).map(k => parseFloat(k[5]));

      // è®¡ç®—åŸºå‡†æå€¼
      const maxHigh48 = Math.max(...kline48Highs);
      const minLow48 = Math.min(...kline48Lows);
      const avgVolume48 = kline48Volumes.reduce((sum, vol) => sum + vol, 0) / kline48Volumes.length;

      // ç¬¬49æ ¹å’Œç¬¬50æ ¹Kçº¿ï¼ˆç¬¬51æ ¹ä½œä¸ºæœ€æ–°æ•°æ®å¤‡ç”¨ï¼‰
      const k49High = parseFloat(data[48][2]);
      const k49Low = parseFloat(data[48][3]);
      const k49Volume = parseFloat(data[48][5]);

      const k50High = parseFloat(data[49][2]);
      const k50Low = parseFloat(data[49][3]);
      const k50Volume = parseFloat(data[49][5]);

      // æ”¾é‡è®¡ç®—ï¼šæœ€è¿‘2æ ¹ï¼ˆ49+50ï¼‰å¹³å‡ vs å‰48æ ¹å¹³å‡
      const recentVolume = (k49Volume + k50Volume) / 2;
      const volumeSpike = recentVolume / avgVolume48;

      return {
        maxHigh48,
        minLow48,
        k49High,
        k49Low,
        k50High,
        k50Low,
        volumeSpike
      };
    }

    // è·å–æœ€æ–°å¿«è®¯
    async function fetchNews() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡æœ€æ–°å¿«è®¯æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followinæœ€æ–°å¿«è®¯æ¥å£...');

        const response = await fetchWithRetry(`https://api.followin.io/open/feed/news?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&count=10`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `æœ€æ–°å¿«è®¯æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (news.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `æœ€æ–°å¿«è®¯æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          news = data.data.list;
          saveNewsData();
        } else if (data.code && data.code !== 2000) {
          addLog('error', `APIè¿”å›é”™è¯¯ç : ${data.code}`, data.msg || 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æœ‰æ•ˆ');
        } else {
          addLog('warning', 'æœ€æ–°å¿«è®¯æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'æœ€æ–°å¿«è®¯æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (news.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] æœ€æ–°å¿«è®¯æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // è·å–çƒ­é—¨å¿«è®¯
    async function fetchHotNews() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡çƒ­é—¨å¿«è®¯æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followinçƒ­é—¨å¿«è®¯æ¥å£...');

        const response = await fetchWithRetry(`https://api.followin.io/open/feed/list/trending?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&type=hot_news&count=10`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `çƒ­é—¨å¿«è®¯æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (hotNews.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          hotNews = data.data.list;
          saveNewsData();
        } else if (data.code && data.code !== 2000) {
          addLog('error', `APIè¿”å›é”™è¯¯ç : ${data.code}`, data.msg || 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æœ‰æ•ˆ');
        } else {
          addLog('warning', 'çƒ­é—¨å¿«è®¯æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (hotNews.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // è·å–KOLè§‚ç‚¹
    async function fetchKolOpinions() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡KOLè§‚ç‚¹æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followin KOLè§‚ç‚¹æ¥å£...');

        // KOLè§‚ç‚¹éœ€è¦æŒ‡å®šsymbolå‚æ•°ï¼Œè¿™é‡Œä½¿ç”¨BTCä½œä¸ºé»˜è®¤å€¼
        const response = await fetchWithRetry(`https://api.followin.io/open/feed/list/tag/opinions?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&count=10&symbol=BTC`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `KOLè§‚ç‚¹æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (kolOpinions.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `KOLè§‚ç‚¹æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          kolOpinions = data.data.list;
          saveNewsData();
        } else if (data.code && data.code !== 2000) {
          addLog('warning', `KOLè§‚ç‚¹æ¥å£è¿”å›é”™è¯¯ç : ${data.code}`, `${data.msg || 'APIæš‚ä¸å¯ç”¨ï¼Œå°è¯•ä½¿ç”¨å…¶ä»–æ ‡ç­¾'}`);
        } else {
          addLog('warning', 'KOLè§‚ç‚¹æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'KOLè§‚ç‚¹æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (kolOpinions.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] KOLè§‚ç‚¹æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // å•ç‹¬åˆ·æ–°æ–°é—»æ•°æ®ï¼ˆç”¨äºAPI Keyé…ç½®åï¼‰
    async function refreshNewsData() {
      await Promise.all([
        fetchNews(),
        fetchHotNews(),
        fetchKolOpinions()
      ]);
      updateNewsView();
    }

    // ==================== UI æ›´æ–°å‡½æ•° ====================

    function updateAPIStatus(status, message) {
      const indicator = document.getElementById('apiStatusIndicator');
      const text = document.getElementById('apiStatusText');

      if (!indicator || !text) return;

      switch (status) {
        case 'connecting':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse';
          text.textContent = message || 'APIè¿æ¥ä¸­';
          break;
        case 'success':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-green-400';
          text.textContent = message || 'APIæ­£å¸¸';
          break;
        case 'error':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-orange-400';
          text.textContent = message || 'APIå¼‚å¸¸';
          break;
        default:
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-slate-400';
          text.textContent = message || 'æœªçŸ¥çŠ¶æ€';
      }
    }

    function updateProgress(current, total) {
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');

      if (!progressBar || !progressFill) return;

      if (total > 0) {
        progressBar.classList.remove('hidden');
        const percentage = Math.round((current / total) * 100);
        progressFill.style.width = `${percentage}%`;
      } else {
        progressBar.classList.add('hidden');
      }
    }

    function hideProgress() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.classList.add('hidden');
      }
    }

    function updateLastUpdateTime() {
      const lastUpdate = document.getElementById('lastUpdate');
      if (lastUpdate) {
        lastUpdate.textContent = 'æœ€åæ›´æ–°: ' + new Date().toLocaleTimeString();
      }
    }

    function updateAnomalyStatus(status) {
      const indicator = document.getElementById('anomalyStatusIndicator');
      const text = document.getElementById('anomalyStatus');

      if (status === 'analyzing') {
        indicator.className = 'w-2 h-2 rounded-full bg-yellow-400 animate-pulse';
        text.textContent = 'åˆ†æä¸­';
        // ä¸éšè—å†…å®¹ï¼Œè®©ç”¨æˆ·ç»§ç»­æŸ¥çœ‹å·²æœ‰ä¿¡å·
        document.getElementById('anomalyLoading').classList.add('hidden');
        document.getElementById('anomalyContent').classList.remove('hidden');
      } else if (status === 'idle') {
        indicator.className = 'w-2 h-2 rounded-full bg-green-400';
        text.textContent = 'å®æ—¶ç›‘æ§';
        document.getElementById('anomalyLastUpdate').textContent = 'æ›´æ–°: ' + new Date().toLocaleTimeString();
      }
    }

    function updateAnomalyView() {
      const loading = document.getElementById('anomalyLoading');
      const empty = document.getElementById('anomalyEmpty');
      const content = document.getElementById('anomalyContent');

      if (!loading || !empty || !content) {
        addLog('warning', 'å¼‚åŠ¨ç›‘æ§é¢æ¿DOMå…ƒç´ æœªå°±ç»ª');
        return;
      }

      loading.classList.add('hidden');

      addLog('info', `æ›´æ–°å¼‚åŠ¨ç›‘æ§è§†å›¾ï¼Œå½“å‰ä¿¡å·æ•°é‡: ${anomalySignals.length}`);

      if (anomalySignals.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      empty.classList.add('hidden');
      content.classList.remove('hidden');

      const table = document.getElementById('anomalySignalsTable');
      if (!table) return;

      // æ˜¾ç¤ºæ‰€æœ‰ä¿¡å·ï¼Œé€šè¿‡å›ºå®šé«˜åº¦å’Œæ»šåŠ¨æ¡æ§åˆ¶æ˜¾ç¤ºåŒºåŸŸ
      const filteredSignals = getFilteredAndSortedAnomalySignals();
      table.innerHTML = filteredSignals.map((signal, index) => `
        <tr class="border-b border-slate-700 hover:bg-slate-700/30 transition-colors ${index === 0 ? 'bg-yellow-500/10' : ''}">
          <td class="px-2 py-1 font-bold text-white text-xs cursor-pointer hover:text-emerald-400" onclick="showCoinDetail('${signal.symbol}')">
            ${signal.symbol}
            ${signal.count > 1 ? `<span class="ml-1 px-1.5 py-0.5 bg-yellow-500/20 text-yellow-300 rounded-full text-xs font-medium">${signal.count}æ¬¡</span>` : ''}
          </td>
          <td class="px-2 py-1">
            <span class="px-2 py-0.5 rounded-full text-xs font-medium text-white ${getSignalTypeClass(signal.strategy)}">
              ${getSignalTypeText(signal.strategy)}
            </span>
          </td>
          <td class="px-2 py-1 text-white font-mono font-medium text-xs">
            ${signal.price ? '$' + parseFloat(signal.price).toFixed(signal.price < 1 ? 6 : 2) : '--'}
          </td>
          <td class="px-2 py-1 text-slate-300 font-mono text-xs">${formatNumber(signal.volume)}M</td>
          <td class="px-2 py-1 text-slate-300 font-mono text-xs">${signal.volumeSpike}</td>
          <td class="px-2 py-1">
            <span class="${signal.change24h >= 0 ? 'text-green-400' : 'text-orange-400'} font-medium text-xs">
              ${signal.change24h >= 0 ? '+' : ''}${signal.change24h.toFixed(2)}%
            </span>
          </td>
          <td class="px-2 py-1 text-slate-400 text-xs">${formatTime(signal.timestamp)}</td>
        </tr>
      `).join('');

      addLog('success', `å·²æ¸²æŸ“å…¨éƒ¨ ${filteredSignals.length} ä¸ªå¼‚åŠ¨ä¿¡å·`);
    }

    function updateNewsView() {
      // æ‰§è¡Œæ–°é—»æ‰¹é‡æ¸…ç†
      cleanupNews();

      const loading = document.getElementById('newsLoading');
      const empty = document.getElementById('newsEmpty');
      const content = document.getElementById('newsContent');

      if (!loading || !empty || !content) {
        addLog('warning', 'æ–°é—»é¢æ¿DOMå…ƒç´ æœªå°±ç»ª');
        return;
      }

      loading.classList.add('hidden');

      if (currentTab === 'hot' && hotNews.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      if (currentTab === 'latest' && news.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      if (currentTab === 'kol' && kolOpinions.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      empty.classList.add('hidden');
      content.classList.remove('hidden');

      // éšè—æ‰€æœ‰å†…å®¹
      const contentHot = document.getElementById('contentHot');
      const contentLatest = document.getElementById('contentLatest');
      const contentKol = document.getElementById('contentKol');

      if (contentHot) contentHot.classList.add('hidden');
      if (contentLatest) contentLatest.classList.add('hidden');
      if (contentKol) contentKol.classList.add('hidden');

      // è¾…åŠ©å‡½æ•°ï¼šå°†æ•°æ®åˆ†é¡µï¼ˆæ¯é¡µ4ä¸ªï¼Œ2è¡Œ2åˆ—ï¼‰
      const chunkArray = (arr, size) => {
        const result = [];
        for (let i = 0; i < arr.length; i += size) {
          result.push(arr.slice(i, i + size));
        }
        return result;
      };

      // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¡ç‰‡HTML
      const generateCardHTML = (item, index, type, totalCount) => {
        const colors = {
          hot: { from: 'from-orange-500/10', to: 'to-amber-600/10', border: 'border-orange-500/30', hoverBorder: 'hover:border-orange-500/50', shadow: 'hover:shadow-orange-500/10', bg: 'hover:bg-orange-500/20' },
          latest: { from: 'from-emerald-500/10', to: 'to-teal-600/10', border: 'border-emerald-500/30', hoverBorder: 'hover:border-emerald-500/50', shadow: 'hover:shadow-emerald-500/10', bg: 'hover:bg-emerald-500/20' },
          kol: { from: 'from-amber-500/10', to: 'to-yellow-600/10', border: 'border-amber-500/30', hoverBorder: 'hover:border-amber-500/50', shadow: 'hover:shadow-amber-500/10', bg: 'hover:bg-amber-500/20' }
        };
        const c = colors[type];

        let headerHTML = '';
        let detailHTML = '';

        if (type === 'hot') {
          headerHTML = `<div class="w-8 h-8 bg-gradient-to-br from-orange-500 to-amber-600 rounded-lg flex items-center justify-center text-white font-bold shrink-0 text-sm">${totalCount + index + 1}</div>`;
          detailHTML = `${item.source_name ? `<span class="px-1.5 py-0.5 bg-orange-500/20 text-orange-300 rounded-md font-medium">${item.source_name}</span>` : ''}`;
        } else if (type === 'latest') {
          headerHTML = item.avatar ? `<img src="${item.avatar}" alt="${item.nickname}" class="w-8 h-8 rounded-full object-cover shrink-0 border border-slate-600" onerror="this.style.display='none'">` : '<div class="w-8 h-8 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-lg flex items-center justify-center text-white text-sm shrink-0">ğŸ“°</div>';
          detailHTML = item.tags && item.tags.length > 0 ? item.tags.slice(0, 2).map(tag => `<span class="px-1.5 py-0.5 bg-emerald-500/20 text-emerald-300 rounded-md font-medium">${tag.symbol || tag.name}</span>`).join('') : '';
        } else if (type === 'kol') {
          headerHTML = item.avatar ? `<img src="${item.avatar}" alt="${item.nickname}" class="w-8 h-8 rounded-full object-cover shrink-0 border border-slate-600" onerror="this.style.display='none'">` : '<div class="w-8 h-8 bg-gradient-to-br from-amber-500 to-yellow-600 rounded-lg flex items-center justify-center text-white text-sm shrink-0">ğŸ‘¤</div>';
          detailHTML = `<span class="text-amber-400 font-semibold text-xs">${item.nickname}</span>`;
        }

        return `
          <div onclick="showNewsDetail(${type === 'hot' ? 'hotNews' : type === 'latest' ? 'news' : 'kolOpinions'}[${totalCount + index}], '${type}')" class="p-3 bg-gradient-to-br ${c.from} ${c.to} rounded-xl border ${c.border} transition-all ${c.hoverBorder} hover:shadow-lg ${c.shadow} min-h-40 flex flex-col cursor-pointer ${c.bg}">
            <div class="flex items-start gap-2 mb-2 shrink-0">
              ${headerHTML}
              <div class="flex-1 min-w-0">
                <h3 class="font-semibold text-white text-sm mb-1 line-clamp-3">${item.title}</h3>
                <div class="flex items-center gap-2 flex-wrap text-xs">
                  <span class="text-slate-400">${formatPublishTime(item.publish_time)}</span>
                  ${detailHTML}
                </div>
              </div>
            </div>
            <p class="text-xs text-slate-400 line-clamp-3 flex-1 leading-relaxed">${item.content || ''}</p>
          </div>
        `;
      };

      // æ˜¾ç¤ºå½“å‰å†…å®¹ï¼ˆ2è¡Œ2åˆ—ï¼Œæ¨ªå‘æ»šåŠ¨åˆ†é¡µï¼‰
      if (currentTab === 'hot' && contentHot) {
        contentHot.classList.remove('hidden');
        contentHot.className = 'flex gap-4 overflow-x-auto snap-x snap-mandatory pb-2';
        contentHot.style.scrollSnapType = 'x mandatory';

        const pages = chunkArray(hotNews, 4);
        contentHot.innerHTML = pages.map((pageItems, pageIndex) => {
          const offset = pageIndex * 4;
          return `
            <div class="snap-start shrink-0 w-[calc(100vw-2rem)] grid grid-cols-2 gap-2">
              ${pageItems.map((item, index) => generateCardHTML(item, index, 'hot', offset)).join('')}
            </div>
          `;
        }).join('');
      } else if (currentTab === 'latest' && contentLatest) {
        contentLatest.classList.remove('hidden');
        contentLatest.className = 'flex gap-4 overflow-x-auto snap-x snap-mandatory pb-2';
        contentLatest.style.scrollSnapType = 'x mandatory';

        const pages = chunkArray(news, 4);
        contentLatest.innerHTML = pages.map((pageItems, pageIndex) => {
          const offset = pageIndex * 4;
          return `
            <div class="snap-start shrink-0 w-[calc(100vw-2rem)] grid grid-cols-2 gap-2">
              ${pageItems.map((item, index) => generateCardHTML(item, index, 'latest', offset)).join('')}
            </div>
          `;
        }).join('');
      } else if (currentTab === 'kol' && contentKol) {
        contentKol.classList.remove('hidden');
        contentKol.className = 'flex gap-4 overflow-x-auto snap-x snap-mandatory pb-2';
        contentKol.style.scrollSnapType = 'x mandatory';

        const pages = chunkArray(kolOpinions, 4);
        contentKol.innerHTML = pages.map((pageItems, pageIndex) => {
          const offset = pageIndex * 4;
          return `
            <div class="snap-start shrink-0 w-[calc(100vw-2rem)] grid grid-cols-2 gap-2">
              ${pageItems.map((item, index) => generateCardHTML(item, index, 'kol', offset)).join('')}
            </div>
          `;
        }).join('');
      }
    }

    // ==================== ç­›é€‰å’Œæ’åºå‡½æ•° ====================

    function getFilteredAndSortedAnomalySignals() {
      let filtered = [...anomalySignals];

      // æ’åº
      filtered.sort((a, b) => {
        let valueA, valueB;

        switch (anomalySortColumn) {
          case 'symbol':
            valueA = a.symbol;
            valueB = b.symbol;
            break;
          case 'volume':
            valueA = a.volume;
            valueB = b.volume;
            break;
          case 'change':
            valueA = Math.abs(a.change24h);
            valueB = Math.abs(b.change24h);
            break;
          case 'time':
            valueA = new Date(a.timestamp).getTime();
            valueB = new Date(b.timestamp).getTime();
            break;
          default:
            return 0;
        }

        if (anomalySortDirection === 'asc') {
          return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
        } else {
          return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
        }
      });

      return filtered;
    }

    function sortAnomalySignals(column) {
      if (anomalySortColumn === column) {
        anomalySortDirection = anomalySortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        anomalySortColumn = column;
        anomalySortDirection = 'desc';
      }

      // æ›´æ–°æ’åºæŒ‡ç¤ºå™¨
      document.querySelectorAll('#anomalyContent th span').forEach(span => {
        span.textContent = '';
      });
      const sortSpan = document.getElementById(`sort${column.charAt(0).toUpperCase() + column.slice(1)}`);
      if (sortSpan) {
        sortSpan.textContent = anomalySortDirection === 'asc' ? 'â†‘' : 'â†“';
      }

      updateAnomalyView();
    }

    function switchTab(tab) {
      currentTab = tab;

      // æ›´æ–°æŒ‰é’®æ ·å¼
      ['Hot', 'Latest', 'Kol'].forEach(name => {
        const btn = document.getElementById(`tab${name}`);
        if (name.toLowerCase() === tab) {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-orange-500 text-white';
        } else {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-700 text-slate-300 hover:bg-slate-600';
        }
      });

      updateNewsView();
    }

    // ==================== å·¥å…·å‡½æ•° ====================

    function formatNumber(num) {
      return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function formatVolume(volume) {
      if (volume >= 1000) {
        return `${(volume / 1000).toFixed(2)}B`;
      } else if (volume >= 1) {
        return `${volume.toFixed(2)}M`;
      } else {
        return `${(volume * 1000).toFixed(2)}K`;
      }
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diff = Math.floor((now - date) / 1000);

      if (diff < 60) return `${diff}ç§’å‰`;
      if (diff < 3600) return `${Math.floor(diff / 60)}åˆ†é’Ÿå‰`;
      if (diff < 86400) return `${Math.floor(diff / 3600)}å°æ—¶å‰`;
      return `${Math.floor(diff / 86400)}å¤©å‰`;
    }

    function formatPublishTime(timestamp) {
      if (!timestamp) return 'æœªçŸ¥';

      // å¤„ç†ç§’çº§æ—¶é—´æˆ³
      const timestampMs = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
      const date = new Date(timestampMs);
      const now = new Date();
      const diff = Math.floor((now - date) / 1000);

      if (diff < 60) return `${diff}ç§’å‰`;
      if (diff < 3600) return `${Math.floor(diff / 60)}åˆ†é’Ÿå‰`;
      if (diff < 86400) return `${Math.floor(diff / 3600)}å°æ—¶å‰`;
      if (diff < 2592000) return `${Math.floor(diff / 86400)}å¤©å‰`; // 30å¤©å†…
      if (diff < 31536000) return `${Math.floor(diff / 2592000)}æœˆå‰`; // 365å¤©å†…
      return `${Math.floor(diff / 31536000)}å¹´å‰`;
    }

    function getSignalTypeClass(strategy) {
      switch (strategy) {
        case 'main_up': return 'bg-gradient-to-r from-green-600 to-emerald-600';
        case 'main_down': return 'bg-gradient-to-r from-orange-600 to-amber-700';
        case 'fund_up': return 'bg-gradient-to-r from-emerald-600 to-teal-600';
        case 'fund_down': return 'bg-gradient-to-r from-amber-600 to-orange-700';
        default: return 'bg-slate-600';
      }
    }

    function getSignalTypeText(strategy) {
      switch (strategy) {
        case 'main_up': return 'ä¸»åŠ›å¼‚åŠ¨æ‹‰ç›˜';
        case 'main_down': return 'ä¸»åŠ›å¼‚åŠ¨ç ¸ç›˜';
        case 'fund_up': return 'èµ„é‡‘å¼‚åŠ¨æ‹‰ç›˜';
        case 'fund_down': return 'èµ„é‡‘å¼‚åŠ¨ç ¸ç›˜';
        default: return 'æœªçŸ¥';
      }
    }

    // ==================== åˆå§‹åŒ–å’Œè‡ªåŠ¨åˆ·æ–° ====================

    async function refreshAll() {
      try {
        addLog('info', 'ğŸ”„ å¼€å§‹åˆ·æ–°æ‰€æœ‰æ•°æ®...');
        updateAPIStatus('connecting', 'APIè¿æ¥ä¸­');
        updateProgress(0, 5);

        let completed = 0;
        let hasError = false;

        // å¸å®‰API
        try {
          await fetchBinancePrices();
        } catch (e) {
          addLog('error', 'å¸å®‰APIåˆ·æ–°å¤±è´¥', e.message);
          hasError = true;
        }
        completed++;
        updateProgress(completed, 5);

        // æ–°é—»API
        try {
          await Promise.all([
            fetchNews(),
            fetchHotNews(),
            fetchKolOpinions()
          ]);
        } catch (e) {
          addLog('error', 'æ–°é—»APIåˆ·æ–°å¤±è´¥', e.message);
          hasError = true;
        }
        completed += 3;
        updateProgress(completed, 5);

        // å¼‚åŠ¨åˆ†æ
        try {
          await fetchAnomalySignals();
        } catch (e) {
          addLog('error', 'å¼‚åŠ¨åˆ†æå¤±è´¥', e.message);
          hasError = true;
        }
        completed++;
        updateProgress(completed, 5);

        // æ›´æ–°UI
        updateLastUpdateTime();
        updateNewsView();
        
        // æ ¹æ®æ˜¯å¦æœ‰é”™è¯¯è®¾ç½®çŠ¶æ€
        if (hasError) {
          updateAPIStatus('success', 'APIæ­£å¸¸ï¼ˆéƒ¨åˆ†å¤±è´¥ï¼‰');
        } else {
          updateAPIStatus('success', 'APIæ­£å¸¸');
        }
        hideProgress();

        addLog('success', 'âœ… æ‰€æœ‰æ•°æ®åˆ·æ–°å®Œæˆ');
      } catch (error) {
        addLog('error', 'æ•°æ®åˆ·æ–°å¤±è´¥', error.message);
        updateAPIStatus('error', 'APIå¼‚å¸¸');
        hideProgress();
        updateLastUpdateTime();
      }
    }

    // ==================== è§¦æ‘¸æ»‘åŠ¨åŠŸèƒ½ ====================
    let touchStartX = 0;
    let touchStartY = 0;

    function handleTouchStart(e) {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }

    function handleTouchEnd(e) {
      const touchEndX = e.changedTouches[0].screenX;
      const touchEndY = e.changedTouches[0].screenY;
      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;

      // åªæœ‰å½“æ¨ªå‘æ»‘åŠ¨è·ç¦»å¤§äºçºµå‘æ»‘åŠ¨è·ç¦»æ—¶ï¼Œæ‰å¤„ç†ä¸ºæ¨ªå‘æ»‘åŠ¨
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 30) {
        // åœ¨æ–°é—»å†…å®¹åŒºåŸŸè¿›è¡Œæ¨ªå‘æ»šåŠ¨ï¼ˆæ¯æ¬¡æ»šåŠ¨ä¸€é¡µï¼‰
        const activeContent = document.querySelector('#newsContent > div:not(.hidden)');
        if (activeContent) {
          // è·å–è§†å£å®½åº¦å‡å»è¾¹è·
          const pageWidth = window.innerWidth - 32; // 100vw - 2rem
          const scrollAmount = Math.round(diffX / pageWidth) * pageWidth || (diffX > 0 ? pageWidth : -pageWidth);
          activeContent.scrollBy({
            left: scrollAmount,
            behavior: 'smooth'
          });
        }
      }
    }

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', async () => {
      addLog('info', 'ğŸš€ é¡µé¢åˆå§‹åŒ–å¼€å§‹...');

      // æ¸…ç†è¿‡æœŸæ•°æ®
      cleanExpiredData();

      // åŠ è½½å†å²æ•°æ®
      loadApiKey();
      loadLogs();
      loadAnomalySignals();
      loadNewsData();
      loadTickerData();

      addLog('info', 'ğŸ“¡ ç›‘æ§æ—¥å¿—ç³»ç»Ÿå·²å¯åŠ¨');
      addLog('info', 'ğŸŒ Followinå®˜ç½‘: https://followin.io');
      addLog('info', 'ğŸ”‘ å·²é¢„ç½®Followin API Keyï¼Œæ–°é—»åŠŸèƒ½å¯æ­£å¸¸ä½¿ç”¨');
      addLog('info', 'ğŸ’¡ è·å–è‡ªå®šä¹‰API Key: è®¿é—®å®˜ç½‘ -> ä¸ªäººä¸­å¿ƒ -> å¼€å‘è€…è®¾ç½®');
      addLog('info', 'ğŸ’¾ æ•°æ®æŒä¹…åŒ–å·²å¯ç”¨ï¼Œå†å²æ•°æ®è‡ªåŠ¨ä¿å­˜ï¼ˆ24å°æ—¶è¿‡æœŸï¼‰');

      // ä¸ºæ–°é—»å†…å®¹å®¹å™¨æ·»åŠ è§¦æ‘¸æ»‘åŠ¨äº‹ä»¶
      const newsSection = document.getElementById('news-section');
      if (newsSection) {
        newsSection.addEventListener('touchstart', handleTouchStart, { passive: true });
        newsSection.addEventListener('touchend', handleTouchEnd, { passive: true });
      }

      // åˆå§‹åŒ–ç»¼åˆä¿¡æ¯æ¿å—
      await refreshMarketData();

      await refreshAll();

      // æ¯5åˆ†é’Ÿè‡ªåŠ¨åˆ·æ–°
      setInterval(refreshAll, 300000);

      // æ¯30ç§’åˆ·æ–°ç»¼åˆä¿¡æ¯æ•°æ®
      setInterval(refreshMarketData, 30000);

      // æ¯å°æ—¶æ¸…ç†è¿‡æœŸæ•°æ®
      setInterval(cleanExpiredData, 3600000);
    });
  </script>
</body>
</html>
